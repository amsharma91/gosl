<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>GoSL &ndash; package tsr</title>
<link type="text/css" rel="stylesheet" href="static/style.css">
<script type="text/javascript" src="static/godocs.js"></script>
<style type="text/css"></style>
</head>
<body>
<div id="page"><h1>GoSL &ndash; <b>tsr</b> &ndash; Tensor algebra and calculus</h1>
<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "code.google.com/p/gosl/tsr"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
tsr implements routines to conduct tensor operations
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#Add">func Add(u [][]float64, α float64, a [][]float64, β float64, b [][]float64)</a></dd>
			
				
				<dd><a href="#Alloc2">func Alloc2() (tensor [][]float64)</a></dd>
			
				
				<dd><a href="#Alloc4">func Alloc4() (tensor [][][][]float64)</a></dd>
			
				
				<dd><a href="#AlmansiStrain">func AlmansiStrain(e, Fi [][]float64)</a></dd>
			
				
				<dd><a href="#CauchyToPK1">func CauchyToPK1(P, σ, F, Fi [][]float64, J float64)</a></dd>
			
				
				<dd><a href="#CauchyToPK2">func CauchyToPK2(S, σ, F, Fi [][]float64, J float64)</a></dd>
			
				
				<dd><a href="#CheckEigenprojs">func CheckEigenprojs(a []float64, usenum bool, tolP, tolS float64, ver bool, evtol, zero float64, dosort bool) (λsorted []float64, Psorted [][]float64)</a></dd>
			
				
				<dd><a href="#CheckEigenprojsDerivs">func CheckEigenprojsDerivs(usenum bool, a []float64, tol float64, ver bool, evtol, zero float64)</a></dd>
			
				
				<dd><a href="#Det">func Det(a [][]float64) float64</a></dd>
			
				
				<dd><a href="#Dev">func Dev(a [][]float64) (deva [][]float64)</a></dd>
			
				
				<dd><a href="#GenInvs">func GenInvs(λ, n []float64, a float64) (p, q float64, err error)</a></dd>
			
				
				<dd><a href="#GenInvsDeriv1">func GenInvsDeriv1(dpdλ, dqdλ []float64, λ, n []float64, dndλ [][]float64, a float64) (p, q float64, err error)</a></dd>
			
				
				<dd><a href="#GenInvsDeriv2">func GenInvsDeriv2(d2pdλdλ, d2qdλdλ [][]float64, λ, n, dpdλ, dqdλ []float64, p, q float64, dndλ [][]float64, d2ndλdλ [][][]float64, a float64)</a></dd>
			
				
				<dd><a href="#GenTvec">func GenTvec(t, λ, n []float64)</a></dd>
			
				
				<dd><a href="#GenTvecDeriv1">func GenTvecDeriv1(dtdλ [][]float64, λ, n []float64, dndλ [][]float64)</a></dd>
			
				
				<dd><a href="#GenTvecDeriv2">func GenTvecDeriv2(i, j, k int, λ []float64, dndλ [][]float64, d2ndλdλ_ijk float64) (res float64)</a></dd>
			
				
				<dd><a href="#GreenStrain">func GreenStrain(E, F [][]float64)</a></dd>
			
				
				<dd><a href="#Inv">func Inv(ai, a [][]float64) (det float64, err error)</a></dd>
			
				
				<dd><a href="#L2O">func L2O(σ1, σ2, σ3 float64) (σa, σb, σc float64)</a></dd>
			
				
				<dd><a href="#LeftCauchyGreenDef">func LeftCauchyGreenDef(b, F [][]float64)</a></dd>
			
				
				<dd><a href="#LinStrain">func LinStrain(ε, F [][]float64)</a></dd>
			
				
				<dd><a href="#M2Phi">func M2Phi(M float64, typ string) float64</a></dd>
			
				
				<dd><a href="#M2T">func M2T(mandel []float64, i, j int) (component float64)</a></dd>
			
				
				<dd><a href="#M2TT">func M2TT(mandel [][]float64, i, j, k, l int) float64</a></dd>
			
				
				<dd><a href="#M_Alloc2">func M_Alloc2(ndim int) (a []float64)</a></dd>
			
				
				<dd><a href="#M_Alloc4">func M_Alloc4(ndim int) (A [][]float64)</a></dd>
			
				
				<dd><a href="#M_AllocEigenprojs">func M_AllocEigenprojs(ncp int) (P [][]float64)</a></dd>
			
				
				<dd><a href="#M_CharInvs">func M_CharInvs(a []float64) (I1, I2, I3 float64)</a></dd>
			
				
				<dd><a href="#M_CharInvsAndDerivs">func M_CharInvsAndDerivs(a []float64) (I1, I2, I3 float64, dI1da, dI2da, dI3da []float64)</a></dd>
			
				
				<dd><a href="#M_Det">func M_Det(a []float64) float64</a></dd>
			
				
				<dd><a href="#M_DetDeriv">func M_DetDeriv(d, a []float64)</a></dd>
			
				
				<dd><a href="#M_Dev">func M_Dev(a []float64) (s []float64)</a></dd>
			
				
				<dd><a href="#M_Dot">func M_Dot(c []float64, a, b []float64, nonsymTol float64) (err error)</a></dd>
			
				
				<dd><a href="#M_Dy">func M_Dy(a, b []float64) (c [][]float64)</a></dd>
			
				
				<dd><a href="#M_DyAdd">func M_DyAdd(c [][]float64, s float64, a, b []float64)</a></dd>
			
				
				<dd><a href="#M_EigenProjsAna">func M_EigenProjsAna(P [][]float64, a, λ []float64, zero float64) (err error)</a></dd>
			
				
				<dd><a href="#M_EigenProjsDeriv">func M_EigenProjsDeriv(dPda [][][]float64, a, λ []float64, P [][]float64, zero float64) (err error)</a></dd>
			
				
				<dd><a href="#M_EigenValsAna">func M_EigenValsAna(λ, a []float64, evtol, zero float64)</a></dd>
			
				
				<dd><a href="#M_EigenValsNum">func M_EigenValsNum(λ, a []float64) (err error)</a></dd>
			
				
				<dd><a href="#M_EigenValsProjsNum">func M_EigenValsProjsNum(P [][]float64, λ, a []float64) (err error)</a></dd>
			
				
				<dd><a href="#M_EigenValsVecsNum">func M_EigenValsVecsNum(Q [][]float64, λ, a []float64) (err error)</a></dd>
			
				
				<dd><a href="#M_FixZeroOrRepeated">func M_FixZeroOrRepeated(λ, a []float64, pert, evtol, zero float64) (haspert bool, err error)</a></dd>
			
				
				<dd><a href="#M_Inv">func M_Inv(ai, a []float64, tol float64) (det float64, err error)</a></dd>
			
				
				<dd><a href="#M_InvDeriv">func M_InvDeriv(d [][]float64, ai []float64)</a></dd>
			
				
				<dd><a href="#M_LodeDeriv1">func M_LodeDeriv1(dwdσ, σ, s []float64, p, q, w float64)</a></dd>
			
				
				<dd><a href="#M_LodeDeriv2">func M_LodeDeriv2(d2wdσdσ [][]float64, dwdσ, σ, s []float64, p, q, w float64)</a></dd>
			
				
				<dd><a href="#M_Norm">func M_Norm(a []float64) float64</a></dd>
			
				
				<dd><a href="#M_PrincValsNum">func M_PrincValsNum(a []float64) (λ0, λ1, λ2 float64, err error)</a></dd>
			
				
				<dd><a href="#M_Sq">func M_Sq(b, a []float64)</a></dd>
			
				
				<dd><a href="#M_SqDeriv">func M_SqDeriv(d [][]float64, a []float64)</a></dd>
			
				
				<dd><a href="#M_Tr">func M_Tr(a []float64) float64</a></dd>
			
				
				<dd><a href="#M_Ts">func M_Ts(Ts [][]float64, s []float64)</a></dd>
			
				
				<dd><a href="#M_devε">func M_devε(e, ε []float64) (eno, εv, εd float64)</a></dd>
			
				
				<dd><a href="#M_devσ">func M_devσ(s, σ []float64) (sno, p, q float64)</a></dd>
			
				
				<dd><a href="#M_oct">func M_oct(a []float64) (σa, σb, σc float64)</a></dd>
			
				
				<dd><a href="#M_p">func M_p(σ []float64) float64</a></dd>
			
				
				<dd><a href="#M_pq_smp">func M_pq_smp(σ []float64, a, b, β, ϵ float64) (p, q float64, err error)</a></dd>
			
				
				<dd><a href="#M_pqw">func M_pqw(a []float64) (p, q, w float64)</a></dd>
			
				
				<dd><a href="#M_pqws">func M_pqws(s, a []float64) (p, q, w float64)</a></dd>
			
				
				<dd><a href="#M_pqθ">func M_pqθ(a []float64) (p, q, θ float64)</a></dd>
			
				
				<dd><a href="#M_q">func M_q(σ []float64) float64</a></dd>
			
				
				<dd><a href="#M_w">func M_w(a []float64) (w float64)</a></dd>
			
				
				<dd><a href="#M_εd">func M_εd(ε []float64) float64</a></dd>
			
				
				<dd><a href="#M_εv">func M_εv(ε []float64) float64</a></dd>
			
				
				<dd><a href="#M_θ">func M_θ(a []float64) (θdeg float64)</a></dd>
			
				
				<dd><a href="#Man2Ten">func Man2Ten(tensor [][]float64, mandel []float64)</a></dd>
			
				
				<dd><a href="#Mmatch">func Mmatch(c, φ float64, cone string) (M, qy0 float64)</a></dd>
			
				
				<dd><a href="#NewSmpCalcμ">func NewSmpCalcμ(φ, a, b, β, ϵ float64) (μ float64)</a></dd>
			
				
				<dd><a href="#NewSmpDerivs1">func NewSmpDerivs1(dndλ [][]float64, dNdλ, N, F, G []float64, λ []float64, a, b, β, ϵ float64) (m float64)</a></dd>
			
				
				<dd><a href="#NewSmpDerivs2">func NewSmpDerivs2(d2ndλdλ [][][]float64, λ []float64, a, b, β, ϵ, m float64, N, F, G, dNdλ []float64, dndλ [][]float64)</a></dd>
			
				
				<dd><a href="#NewSmpDirector">func NewSmpDirector(N, λ []float64, a, b, β, ϵ float64) (m float64)</a></dd>
			
				
				<dd><a href="#NewSmpDirectorDeriv1">func NewSmpDirectorDeriv1(dNdλ []float64, λ []float64, a, b, β, ϵ float64)</a></dd>
			
				
				<dd><a href="#NewSmpDirectorDeriv2">func NewSmpDirectorDeriv2(d2Ndλ2 []float64, λ []float64, a, b, β, ϵ float64)</a></dd>
			
				
				<dd><a href="#NewSmpNormDirectorDeriv1">func NewSmpNormDirectorDeriv1(dmdλ []float64, m float64, N, dNdλ []float64)</a></dd>
			
				
				<dd><a href="#NewSmpNormDirectorDeriv2">func NewSmpNormDirectorDeriv2(d2mdλdλ [][]float64, λ []float64, a, b, β, ϵ, m float64, N, dNdλ, d2Ndλ2, dmdλ []float64)</a></dd>
			
				
				<dd><a href="#NewSmpUnitDirector">func NewSmpUnitDirector(n []float64, m float64, N []float64)</a></dd>
			
				
				<dd><a href="#NewSmpUnitDirectorDeriv1">func NewSmpUnitDirectorDeriv1(dndλ [][]float64, m float64, N, dNdλ, dmdλ []float64)</a></dd>
			
				
				<dd><a href="#NewSmpUnitDirectorDeriv2">func NewSmpUnitDirectorDeriv2(d2ndλdλ [][][]float64, m float64, N, dNdλ, d2Ndλ2, dmdλ, n []float64, d2mdλdλ, dndλ [][]float64)</a></dd>
			
				
				<dd><a href="#O2L">func O2L(σa, σb, σc float64) (σ1, σ2, σ3 float64)</a></dd>
			
				
				<dd><a href="#O2Lmat">func O2Lmat() (L [][]float64)</a></dd>
			
				
				<dd><a href="#PK1ToCauchy">func PK1ToCauchy(σ, P, F, Fi [][]float64, J float64)</a></dd>
			
				
				<dd><a href="#PK2ToCauchy">func PK2ToCauchy(σ, S, F, Fi [][]float64, J float64)</a></dd>
			
				
				<dd><a href="#PQW2O">func PQW2O(p, q, w float64) (σa, σb, σc float64)</a></dd>
			
				
				<dd><a href="#Phi2M">func Phi2M(φ float64, typ string) float64</a></dd>
			
				
				<dd><a href="#PlotOct">func PlotOct(filename string, σcCte, rmin, rmax float64, nr, nα int, φ float64, F Cb_F_t, G Cb_G_t, notpolarc, simplec, only0, grads, showpts, first, last bool, ferr float64, args ...interface{})</a></dd>
			
				
				<dd><a href="#PlotRefOct">func PlotRefOct(φ, σc float64, withExtCircle bool)</a></dd>
			
				
				<dd><a href="#PlotRosette">func PlotRosette(r float64, full, ref bool, withtext bool, fsz float64)</a></dd>
			
				
				<dd><a href="#PullBack">func PullBack(res, a, F, Fi [][]float64)</a></dd>
			
				
				<dd><a href="#PullBackB">func PullBackB(res, a, F, Fi [][]float64)</a></dd>
			
				
				<dd><a href="#PushForward">func PushForward(res, a, F, Fi [][]float64)</a></dd>
			
				
				<dd><a href="#PushForwardB">func PushForwardB(res, a, F, Fi [][]float64)</a></dd>
			
				
				<dd><a href="#RightCauchyGreenDef">func RightCauchyGreenDef(C, F [][]float64)</a></dd>
			
				
				<dd><a href="#SMPderivs1">func SMPderivs1(dpdλ, dqdλ, λ []float64, a, b, β, ϵ float64) (p, q float64, err error)</a></dd>
			
				
				<dd><a href="#SMPinvs">func SMPinvs(λ []float64, a, b, β, ϵ float64) (p, q float64, err error)</a></dd>
			
				
				<dd><a href="#ShiftedEigenvs">func ShiftedEigenvs(λ, λbar []float64, λc, tol float64) (err error)</a></dd>
			
				
				<dd><a href="#SmpCalcμ">func SmpCalcμ(φ, b float64) (μ float64)</a></dd>
			
				
				<dd><a href="#SmpCalcμNum">func SmpCalcμNum(φ, b float64) (μ float64)</a></dd>
			
				
				<dd><a href="#SmpDerivs">func SmpDerivs(d2mdσdσ, dndσ [][]float64, dmdσ, n, σ []float64, b float64) (m float64)</a></dd>
			
				
				<dd><a href="#SmpDirector">func SmpDirector(N, σ []float64, b float64)</a></dd>
			
				
				<dd><a href="#SmpDirectorDeriv1">func SmpDirectorDeriv1(dNdσ [][]float64, σ []float64, b float64)</a></dd>
			
				
				<dd><a href="#SmpDirectorDeriv2">func SmpDirectorDeriv2(i, j, k int, σ []float64, b float64) (res float64)</a></dd>
			
				
				<dd><a href="#SmpNormDirectorDeriv1">func SmpNormDirectorDeriv1(dmdσ []float64, σ []float64, b float64) (m float64)</a></dd>
			
				
				<dd><a href="#SmpNormDirectorDeriv2">func SmpNormDirectorDeriv2(d2mdσdσ [][]float64, σ []float64, b, m float64, dmdσ []float64)</a></dd>
			
				
				<dd><a href="#SmpUnitDirector">func SmpUnitDirector(n, σ []float64, b float64) (m float64)</a></dd>
			
				
				<dd><a href="#SmpUnitDirectorDeriv1">func SmpUnitDirectorDeriv1(dndσ [][]float64, σ, n []float64, b, m float64, dmdσ []float64)</a></dd>
			
				
				<dd><a href="#SmpUnitDirectorDeriv2">func SmpUnitDirectorDeriv2(d2ndσdσ [][][]float64, σ, n, dmdσ []float64, b, m float64, d2mdσdσ, dndσ [][]float64)</a></dd>
			
				
				<dd><a href="#Ten2Man">func Ten2Man(mandel []float64, tensor [][]float64)</a></dd>
			
				
				<dd><a href="#Tr">func Tr(a [][]float64) float64</a></dd>
			
			
				
				<dd><a href="#Cb_F_t">type Cb_F_t</a></dd>
				
				
			
				
				<dd><a href="#Cb_G_t">type Cb_G_t</a></dd>
				
				
			
				
				<dd><a href="#Cb_isofun_f">type Cb_isofun_f</a></dd>
				
				
			
				
				<dd><a href="#Cb_isofun_g">type Cb_isofun_g</a></dd>
				
				
			
				
				<dd><a href="#Cb_isofun_h">type Cb_isofun_h</a></dd>
				
				
			
				
				<dd><a href="#IsoFun">type IsoFun</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.ApplyPert">func (o *IsoFun) ApplyPert(A []float64) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.CheckGrads">func (o *IsoFun) CheckGrads(A []float64, tol, tol2 float64, ver bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.DebugOutput">func (o *IsoFun) DebugOutput(princOnly bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Fa">func (o *IsoFun) Fa(A []float64, args ...interface{}) (res float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.FindIntersect">func (o *IsoFun) FindIntersect(p0, k float64, Δλ []float64, usek, debug bool, args ...interface{}) (λ_at_int []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Fp">func (o *IsoFun) Fp(λ []float64, args ...interface{}) (res float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Ga">func (o *IsoFun) Ga(dfdA, A []float64, args ...interface{}) (fval float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Get_bsmp">func (o *IsoFun) Get_bsmp() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Get_derivs_afterHa">func (o *IsoFun) Get_derivs_afterHa(dpdσ, dqdσ []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Get_pq">func (o *IsoFun) Get_pq() (p, q float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Gp">func (o *IsoFun) Gp(λ []float64, args ...interface{}) (fval float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.HafterGa">func (o *IsoFun) HafterGa(d2fdAdA [][]float64, args ...interface{}) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.HafterGp">func (o *IsoFun) HafterGp(args ...interface{}) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Init">func (o *IsoFun) Init(a, b, β, ϵ, shift float64, ncp int, ffcn Cb_isofun_f, gfcn Cb_isofun_g, hfcn Cb_isofun_h)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Set_bsmp">func (o *IsoFun) Set_bsmp(b float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.String">func (o *IsoFun) String() (l string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.View">func (o *IsoFun) View(l float64, λ []float64, grads bool, gradsFtol float64, extraconf func(is *vtk.IsoSurf), args ...interface{})</a></dd>
				
			
				
				<dd><a href="#NcteM">type NcteM</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.D2Mdw2">func (o *NcteM) D2Mdw2(w float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.DMdw">func (o *NcteM) DMdw(w float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.Deriv1">func (o *NcteM) Deriv1(dMdσ, σ, s []float64, p, q, w float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.Deriv2">func (o *NcteM) Deriv2(d2Mdσdσ [][]float64, dMdσ, σ, s []float64, p, q, w float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.Init">func (o *NcteM) Init(prms []string, vals []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.M">func (o *NcteM) M(w float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.String">func (o *NcteM) String() (s string)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/code.google.com/p/gosl/tsr/contmech.go">contmech.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/eigenprojs.go">eigenprojs.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/fcritcoef.go">fcritcoef.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/generalinvs.go">generalinvs.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/invariants.go">invariants.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/isofun.go">isofun.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/mandelops.go">mandelops.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/nonctem.go">nonctem.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/octahedral.go">octahedral.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/operators.go">operators.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/smpinvsV1.go">smpinvsV1.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/smpinvsV2.go">smpinvsV2.go</a>
			
				<a href="/src/code.google.com/p/gosl/tsr/tensor.go">tensor.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
    <span id="EPS">EPS</span>        = 1e-16 <span class="comment">// smallest number satisfying 1.0 + EPS &gt; 1.0</span>
    <span id="QMIN">QMIN</span>       = 1e-10 <span class="comment">// smallest q value to compute qCam invariant</span>
    <span id="MINDET">MINDET</span>     = 1e-14 <span class="comment">// minimum determinant of tensor</span>
    <span id="SMPINVSTOL">SMPINVSTOL</span> = 1e-8  <span class="comment">// tolerance used in SmpInvs to avoid sqrt(negativenumber)</span>
    <span id="EV_DEBUG">EV_DEBUG</span>   = <a href="/pkg/builtin/#false">false</a> <span class="comment">// flag to activate debugging of eivenvalues/projectors</span>
    <span id="EV_DNMIN">EV_DNMIN</span>   = 1e-10 <span class="comment">// minimum denominator to be used in analytical eigenprojectors computation</span>
    <span id="EV_ALPMIN">EV_ALPMIN</span>  = 1e-12 <span class="comment">// minimum α to be used in eigenprojectors derivatives</span>
    <span id="EV_PERT">EV_PERT</span>    = 1e-3  <span class="comment">// perturbation value</span>
    <span id="EV_EVTOL">EV_EVTOL</span>   = 1e-6  <span class="comment">// mfac coefficient</span>
    <span id="EV_ZERO">EV_ZERO</span>    = 1e-8  <span class="comment">// minimum eigenvalue</span>
)</pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span class="comment">// T2MI converts i-j-indices of 3x3 2nd order tensor to I-index in Mandel&#39;s representation</span>
    <span id="T2MI">T2MI</span> = [][]<a href="/pkg/builtin/#int">int</a>{
        {0, 3, 5},
        {3, 1, 4},
        {5, 4, 2},
    }

    <span class="comment">// TT2MI converts i-j-k-l-indices of 3x3x3x3 4th order tensor to I-index in Mandel&#39;s representation</span>
    <span id="TT2MI">TT2MI</span> = [][][][]<a href="/pkg/builtin/#int">int</a>{
        {{{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {{3, 3, 3}, {3, 3, 3}, {3, 3, 3}}, {{5, 5, 5}, {5, 5, 5}, {5, 5, 5}}},
        {{{3, 3, 3}, {3, 3, 3}, {3, 3, 3}}, {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, {{4, 4, 4}, {4, 4, 4}, {4, 4, 4}}},
        {{{5, 5, 5}, {5, 5, 5}, {5, 5, 5}}, {{4, 4, 4}, {4, 4, 4}, {4, 4, 4}}, {{2, 2, 2}, {2, 2, 2}, {2, 2, 2}}},
    }

    <span class="comment">// TT2MJ converts i-j-k-l-indices of 3x3x3x3 4th order tensor to J-index in Mandel&#39;s representation</span>
    <span id="TT2MJ">TT2MJ</span> = [][][][]<a href="/pkg/builtin/#int">int</a>{
        {{{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}},
        {{{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}},
        {{{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}},
    }

    <span class="comment">// M2Ti converts I-index in Mandel&#39;s representation to i-index of 3x3 2nd order tensor</span>
    <span id="M2Ti">M2Ti</span> = []<a href="/pkg/builtin/#int">int</a>{0, 1, 2, 0, 1, 0}

    <span class="comment">// M2Tj converts I-index in Mandel&#39;s representation to j-index of 3x3 2nd order tensor</span>
    <span id="M2Tj">M2Tj</span> = []<a href="/pkg/builtin/#int">int</a>{0, 1, 2, 1, 2, 2}

    <span class="comment">// constants</span>
    <span id="SQ2">SQ2</span>    = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(2.0)       <span class="comment">// sqrt(2)</span>
    <span id="SQ3">SQ3</span>    = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(3.0)       <span class="comment">// sqrt(3)</span>
    <span id="SQ6">SQ6</span>    = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(6.0)       <span class="comment">// sqrt(6)</span>
    <span id="SQ3by2">SQ3by2</span> = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(3.0 / 2.0) <span class="comment">// sqrt(3/2)</span>
    <span id="SQ2by3">SQ2by3</span> = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(2.0 / 3.0) <span class="comment">// sqrt(2/3)</span>
    <span id="TWOSQ2">TWOSQ2</span> = 2.0 * <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(2.0) <span class="comment">// 2*sqrt(2) == 2^(3/2)</span>

    <span class="comment">// 3x3 2nd order identity tensor</span>
    <span id="It">It</span> = [][]<a href="/pkg/builtin/#float64">float64</a>{
        {1, 0, 0},
        {0, 1, 0},
        {0, 0, 1},
    }

    <span class="comment">// 3x3 2nd order identity tensor in Mandel&#39;s representation</span>
    <span id="Im">Im</span> = []<a href="/pkg/builtin/#float64">float64</a>{1, 1, 1, 0, 0, 0}

    <span class="comment">// 4th order identity tensor (symmetric) in Mandel&#39;s representation</span>
    <span id="IIm">IIm</span> = [][]<a href="/pkg/builtin/#float64">float64</a>{
        {1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
    }

    <span class="comment">// symmetric-deviatoric projector (3D) in Mandel&#39;s representation</span>
    <span class="comment">//Psd3dm = [][]float64{</span>
    <span id="Psd">Psd</span> = [][]<a href="/pkg/builtin/#float64">float64</a>{
        {2.0 / 3.0, -1.0 / 3.0, -1.0 / 3.0, 0.0, 0.0, 0.0},
        {-1.0 / 3.0, 2.0 / 3.0, -1.0 / 3.0, 0.0, 0.0, 0.0},
        {-1.0 / 3.0, -1.0 / 3.0, 2.0 / 3.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
    }

    <span class="comment">// isotropic projector (3D) in Mandel&#39;s representation</span>
    <span class="comment">//Piso3dm = [][]float64{</span>
    <span id="Piso">Piso</span> = [][]<a href="/pkg/builtin/#float64">float64</a>{
        {1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 0.0, 0.0, 0.0},
        {1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 0.0, 0.0, 0.0},
        {1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    }
)</pre>
				
			
		
		
			
			
			<h2 id="Add">func <a href="/src/target/operators.go?s=1758:1835#L49">Add</a></h2>
			<pre>func Add(u [][]<a href="/pkg/builtin/#float64">float64</a>, α <a href="/pkg/builtin/#float64">float64</a>, a [][]<a href="/pkg/builtin/#float64">float64</a>, β <a href="/pkg/builtin/#float64">float64</a>, b [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Add adds two second order tensors according to:
</p>
<pre>u := α*a + β*b
</pre>

			
			

		
			
			
			<h2 id="Alloc2">func <a href="/src/target/tensor.go?s=4025:4059#L96">Alloc2</a></h2>
			<pre>func Alloc2() (tensor [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Alloc2 allocates a 3x3 2nd order tensor
</p>

			
			

		
			
			
			<h2 id="Alloc4">func <a href="/src/target/tensor.go?s=4231:4269#L105">Alloc4</a></h2>
			<pre>func Alloc4() (tensor [][][][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Alloc4 allocates a 3x3x3x3 4th order tensor
</p>

			
			

		
			
			
			<h2 id="AlmansiStrain">func <a href="/src/target/contmech.go?s=1370:1407#L41">AlmansiStrain</a></h2>
			<pre>func AlmansiStrain(e, Fi [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Eulerian or Almansi strain tensor: e := 0.5 * (I - inv(F)^t * inv(F))
Symmetric
</p>

			
			

		
			
			
			<h2 id="CauchyToPK1">func <a href="/src/target/contmech.go?s=2058:2111#L68">CauchyToPK1</a></h2>
			<pre>func CauchyToPK1(P, σ, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>, J <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Cauchy stress =&gt; first Piola-Kirchhoff: P := σ * inv(F)^t * J
</p>

			
			

		
			
			
			<h2 id="CauchyToPK2">func <a href="/src/target/contmech.go?s=2724:2777#L92">CauchyToPK2</a></h2>
			<pre>func CauchyToPK2(S, σ, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>, J <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Cauchy stress =&gt; second Piola-Kirchhoff: S := inv(F) * σ * inv(F)^t * J
</p>

			
			

		
			
			
			<h2 id="CheckEigenprojs">func <a href="/src/target/eigenprojs.go?s=10226:10378#L363">CheckEigenprojs</a></h2>
			<pre>func CheckEigenprojs(a []<a href="/pkg/builtin/#float64">float64</a>, usenum <a href="/pkg/builtin/#bool">bool</a>, tolP, tolS <a href="/pkg/builtin/#float64">float64</a>, ver <a href="/pkg/builtin/#bool">bool</a>, evtol, zero <a href="/pkg/builtin/#float64">float64</a>, dosort <a href="/pkg/builtin/#bool">bool</a>) (λsorted []<a href="/pkg/builtin/#float64">float64</a>, Psorted [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="CheckEigenprojsDerivs">func <a href="/src/target/eigenprojs.go?s=12764:12860#L457">CheckEigenprojsDerivs</a></h2>
			<pre>func CheckEigenprojsDerivs(usenum <a href="/pkg/builtin/#bool">bool</a>, a []<a href="/pkg/builtin/#float64">float64</a>, tol <a href="/pkg/builtin/#float64">float64</a>, ver <a href="/pkg/builtin/#bool">bool</a>, evtol, zero <a href="/pkg/builtin/#float64">float64</a>)</pre>
			
			
			

		
			
			
			<h2 id="Det">func <a href="/src/target/operators.go?s=667:698#L20">Det</a></h2>
			<pre>func Det(a [][]<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Det computes the determinant of a second order tensor
</p>

			
			

		
			
			
			<h2 id="Dev">func <a href="/src/target/operators.go?s=406:448#L9">Dev</a></h2>
			<pre>func Dev(a [][]<a href="/pkg/builtin/#float64">float64</a>) (deva [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Dev returns the second order deviatoric tensor
</p>

			
			

		
			
			
			<h2 id="GenInvs">func <a href="/src/target/generalinvs.go?s=801:867#L19">GenInvs</a></h2>
			<pre>func GenInvs(λ, n []<a href="/pkg/builtin/#float64">float64</a>, a <a href="/pkg/builtin/#float64">float64</a>) (p, q <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
GenInvs returns the SMP invariants
</p>
<pre>Note: λ are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GenInvsDeriv1">func <a href="/src/target/generalinvs.go?s=2354:2469#L69">GenInvsDeriv1</a></h2>
			<pre>func GenInvsDeriv1(dpdλ, dqdλ []<a href="/pkg/builtin/#float64">float64</a>, λ, n []<a href="/pkg/builtin/#float64">float64</a>, dndλ [][]<a href="/pkg/builtin/#float64">float64</a>, a <a href="/pkg/builtin/#float64">float64</a>) (p, q <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
GenInvsDeriv1 computes the first order derivatives of p and q w.r.t λ (shifted eigenvalues)
</p>
<pre>Note: λ are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GenInvsDeriv2">func <a href="/src/target/generalinvs.go?s=3502:3654#L104">GenInvsDeriv2</a></h2>
			<pre>func GenInvsDeriv2(d2pdλdλ, d2qdλdλ [][]<a href="/pkg/builtin/#float64">float64</a>, λ, n, dpdλ, dqdλ []<a href="/pkg/builtin/#float64">float64</a>, p, q <a href="/pkg/builtin/#float64">float64</a>, dndλ [][]<a href="/pkg/builtin/#float64">float64</a>, d2ndλdλ [][][]<a href="/pkg/builtin/#float64">float64</a>, a <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
GenInvsDeriv2 computes the second order derivatives of p and q w.r.t λ (shifted eigenvalues)
</p>
<pre>Note: λ are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GenTvec">func <a href="/src/target/generalinvs.go?s=1368:1400#L35">GenTvec</a></h2>
			<pre>func GenTvec(t, λ, n []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
GenTvec computes the t vector (stress vector on SMP via Cauchy&#39;s rule: t = λ dot n)
</p>
<pre>Note: λ are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GenTvecDeriv1">func <a href="/src/target/generalinvs.go?s=1573:1646#L43">GenTvecDeriv1</a></h2>
			<pre>func GenTvecDeriv1(dtdλ [][]<a href="/pkg/builtin/#float64">float64</a>, λ, n []<a href="/pkg/builtin/#float64">float64</a>, dndλ [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
GenTvecDeriv1 computes the first derivative dt/dλ
</p>
<pre>Note: λ are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GenTvecDeriv2">func <a href="/src/target/generalinvs.go?s=1960:2061#L56">GenTvecDeriv2</a></h2>
			<pre>func GenTvecDeriv2(i, j, k <a href="/pkg/builtin/#int">int</a>, λ []<a href="/pkg/builtin/#float64">float64</a>, dndλ [][]<a href="/pkg/builtin/#float64">float64</a>, d2ndλdλ_ijk <a href="/pkg/builtin/#float64">float64</a>) (res <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
GenTvecDeriv2 computes the second derivative d²t/dλdλ
</p>
<pre>Note: λ are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GreenStrain">func <a href="/src/target/contmech.go?s=969:1003#L25">GreenStrain</a></h2>
			<pre>func GreenStrain(E, F [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Lagrangian or Green strain tensor: E := 0.5 * (Ft * F - I)
Symmetric
</p>

			
			

		
			
			
			<h2 id="Inv">func <a href="/src/target/operators.go?s=912:964#L26">Inv</a></h2>
			<pre>func Inv(ai, a [][]<a href="/pkg/builtin/#float64">float64</a>) (det <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
Inv computes the inverse of a second order tensor
</p>
<pre>ai := Inv(a)
</pre>

			
			

		
			
			
			<h2 id="L2O">func <a href="/src/target/octahedral.go?s=387:442#L5">L2O</a></h2>
			<pre>func L2O(σ1, σ2, σ3 <a href="/pkg/builtin/#float64">float64</a>) (σa, σb, σc <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
L2O converts principal values (σ1,σ2,σ3) to octahedral values (σa,σb,σc)
</p>

			
			

		
			
			
			<h2 id="LeftCauchyGreenDef">func <a href="/src/target/contmech.go?s=647:688#L12">LeftCauchyGreenDef</a></h2>
			<pre>func LeftCauchyGreenDef(b, F [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Left Cauchy-Green deformation tensor: b := F * Ft
Symmetric and positive definite: det(b) = det(F)^2
</p>

			
			

		
			
			
			<h2 id="LinStrain">func <a href="/src/target/contmech.go?s=1756:1789#L56">LinStrain</a></h2>
			<pre>func LinStrain(ε, F [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Linear strain tensor: ε := 0.5 * (H + Ht) = 0.5 * (F + Ft) - I
</p>

			
			

		
			
			
			<h2 id="M2Phi">func <a href="/src/target/fcritcoef.go?s=1749:1790#L48">M2Phi</a></h2>
			<pre>func M2Phi(M <a href="/pkg/builtin/#float64">float64</a>, typ <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M2Phi calculates φ (friction angle at compression (degrees)) given M (max q/p at compression)
</p>

			
			

		
			
			
			<h2 id="M2T">func <a href="/src/target/tensor.go?s=5362:5418#L147">M2T</a></h2>
			<pre>func M2T(mandel []<a href="/pkg/builtin/#float64">float64</a>, i, j <a href="/pkg/builtin/#int">int</a>) (component <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M2T converts Mandel components to 3x3 second order tensor components,
i.e. correcting off-diagonal values that were multiplied by SQ2
</p>

			
			

		
			
			
			<h2 id="M2TT">func <a href="/src/target/tensor.go?s=5963:6016#L168">M2TT</a></h2>
			<pre>func M2TT(mandel [][]<a href="/pkg/builtin/#float64">float64</a>, i, j, k, l <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M2TT converts Mandel components to 3x3x3x3 fourth order tensor components,
i.e. correcting all values that were multiplied by 2 or SQ2
</p>

			
			

		
			
			
			<h2 id="M_Alloc2">func <a href="/src/target/tensor.go?s=4674:4711#L120">M_Alloc2</a></h2>
			<pre>func M_Alloc2(ndim <a href="/pkg/builtin/#int">int</a>) (a []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Alloc2 allocates a 2th order tensor in Mandel&#39;s representation (2*ndim)
</p>

			
			

		
			
			
			<h2 id="M_Alloc4">func <a href="/src/target/tensor.go?s=4867:4906#L127">M_Alloc4</a></h2>
			<pre>func M_Alloc4(ndim <a href="/pkg/builtin/#int">int</a>) (A [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Alloc4 allocates a 4th order tensor in Mandel&#39;s representation ((2*ndim)x(2*ndim))
</p>

			
			

		
			
			
			<h2 id="M_AllocEigenprojs">func <a href="/src/target/eigenprojs.go?s=1477:1524#L44">M_AllocEigenprojs</a></h2>
			<pre>func M_AllocEigenprojs(ncp <a href="/pkg/builtin/#int">int</a>) (P [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_AllocEigenprojs allocates new eigenprojectors P[3][ncp].
</p>
<pre>P[0] = {P0_0, P0_1, P0_2, P0_3, P0_4, P0_5}
P[1] = {P1_0, P1_1, P1_2, P1_3, P1_4, P1_5}
P[2] = {P2_0, P2_1, P2_2, P2_3, P2_4, P2_5}
</pre>

			
			

		
			
			
			<h2 id="M_CharInvs">func <a href="/src/target/invariants.go?s=7854:7903#L233">M_CharInvs</a></h2>
			<pre>func M_CharInvs(a []<a href="/pkg/builtin/#float64">float64</a>) (I1, I2, I3 <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_CharInvs computes the characteristic invariants of a 2nd order symmetric tensor
</p>

			
			

		
			
			
			<h2 id="M_CharInvsAndDerivs">func <a href="/src/target/invariants.go?s=8314:8403#L246">M_CharInvsAndDerivs</a></h2>
			<pre>func M_CharInvsAndDerivs(a []<a href="/pkg/builtin/#float64">float64</a>) (I1, I2, I3 <a href="/pkg/builtin/#float64">float64</a>, dI1da, dI2da, dI3da []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_CharInvsAndDerivs computes the characteristic invariants of a
2nd order symmetric and their derivatives
</p>

			
			

		
			
			
			<h2 id="M_Det">func <a href="/src/target/mandelops.go?s=1041:1072#L25">M_Det</a></h2>
			<pre>func M_Det(a []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_Det calculates the determinant a 2nd order tensor represented in Mandel&#39;s basis
</p>

			
			

		
			
			
			<h2 id="M_DetDeriv">func <a href="/src/target/mandelops.go?s=1369:1400#L34">M_DetDeriv</a></h2>
			<pre>func M_DetDeriv(d, a []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_DetDeriv computes the derivative of the determinant of a w.r.t a
</p>
<pre>d := dDet(a)/da == dI3(a)/da
</pre>

			
			

		
			
			
			<h2 id="M_Dev">func <a href="/src/target/mandelops.go?s=777:814#L16">M_Dev</a></h2>
			<pre>func M_Dev(a []<a href="/pkg/builtin/#float64">float64</a>) (s []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Dev calculates the deviator a 2nd order tensor represented in Mandel&#39;s basis
</p>

			
			

		
			
			
			<h2 id="M_Dot">func <a href="/src/target/mandelops.go?s=4905:4975#L115">M_Dot</a></h2>
			<pre>func M_Dot(c []<a href="/pkg/builtin/#float64">float64</a>, a, b []<a href="/pkg/builtin/#float64">float64</a>, nonsymTol <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_Dot multiplies two second order symmetric tensors (the result may be non-symmetric)
An error is returned in case the result is non-symmetric
</p>
<pre>c = a dot b  =&gt;  cij = aik * bkj
</pre>

			
			

		
			
			
			<h2 id="M_Dy">func <a href="/src/target/mandelops.go?s=3571:3612#L82">M_Dy</a></h2>
			<pre>func M_Dy(a, b []<a href="/pkg/builtin/#float64">float64</a>) (c [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Dy returns the dyadic product between a and b
</p>
<pre>c := a dy b
</pre>

			
			

		
			
			
			<h2 id="M_DyAdd">func <a href="/src/target/mandelops.go?s=4526:4580#L103">M_DyAdd</a></h2>
			<pre>func M_DyAdd(c [][]<a href="/pkg/builtin/#float64">float64</a>, s <a href="/pkg/builtin/#float64">float64</a>, a, b []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_DyAdd adds the dyadic product between a and b scaled by s
</p>
<pre>c += s * a dy b
</pre>

			
			

		
			
			
			<h2 id="M_EigenProjsAna">func <a href="/src/target/eigenprojs.go?s=7132:7210#L279">M_EigenProjsAna</a></h2>
			<pre>func M_EigenProjsAna(P [][]<a href="/pkg/builtin/#float64">float64</a>, a, λ []<a href="/pkg/builtin/#float64">float64</a>, zero <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_EigenProjsAna computes the eigenprojectors of tensor &#39;a&#39; (2nd order symmetric tensor in Mandel&#39;s basis)
using the analytical formula.
</p>

			
			

		
			
			
			<h2 id="M_EigenProjsDeriv">func <a href="/src/target/eigenprojs.go?s=8488:8588#L320">M_EigenProjsDeriv</a></h2>
			<pre>func M_EigenProjsDeriv(dPda [][][]<a href="/pkg/builtin/#float64">float64</a>, a, λ []<a href="/pkg/builtin/#float64">float64</a>, P [][]<a href="/pkg/builtin/#float64">float64</a>, zero <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_EigenProjsDeriv returns the derivatives of the eigenprojectors w.r.t its defining tensor
using the analytical formula.
</p>
<pre>Input:  a      -- (perturbed) tensor &#39;a&#39; (in Mandel basis)
        λ      -- (shifted) eigenvalues of &#39;a&#39;
        P      -- eigenprojectors of &#39;a&#39;
        zero   -- tolerance to assume zero eigenvalues
        usefdm -- use finite difference method instead of analytical formula
Output: dPda   -- the derivatives of P w.r.t &#39;a&#39;
</pre>

			
			

		
			
			
			<h2 id="M_EigenValsAna">func <a href="/src/target/eigenprojs.go?s=5740:5797#L225">M_EigenValsAna</a></h2>
			<pre>func M_EigenValsAna(λ, a []<a href="/pkg/builtin/#float64">float64</a>, evtol, zero <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_EigenValsAna returns the eigenvalues of tensor &#39;a&#39; (2nd order symmetric tensor in Mandel&#39;s basis)
using the analytical formula
</p>

			
			

		
			
			
			<h2 id="M_EigenValsNum">func <a href="/src/target/eigenprojs.go?s=846:894#L23">M_EigenValsNum</a></h2>
			<pre>func M_EigenValsNum(λ, a []<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_EigenValsNum returns the eigenvalues of tensor &#39;a&#39; (2nd order symmetric tensor in Mandel&#39;s basis)
using Jacobi rotation
</p>

			
			

		
			
			
			<h2 id="M_EigenValsProjsNum">func <a href="/src/target/eigenprojs.go?s=1780:1848#L54">M_EigenValsProjsNum</a></h2>
			<pre>func M_EigenValsProjsNum(P [][]<a href="/pkg/builtin/#float64">float64</a>, λ, a []<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_EigenValsProjsNum computes the eigenvalues and eigenprojectors of tensor &#39;a&#39; (2nd order symmetric tensor in Mandel&#39;s basis)
using Jacobi rotation.
</p>

			
			

		
			
			
			<h2 id="M_EigenValsVecsNum">func <a href="/src/target/eigenprojs.go?s=1130:1197#L33">M_EigenValsVecsNum</a></h2>
			<pre>func M_EigenValsVecsNum(Q [][]<a href="/pkg/builtin/#float64">float64</a>, λ, a []<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_EigenValsVecs returns the eigenvalues and eigenvectors of tensor &#39;a&#39; (2nd order symmetric tensor in Mandel&#39;s basis)
using Jacobi rotation.
</p>

			
			

		
			
			
			<h2 id="M_FixZeroOrRepeated">func <a href="/src/target/eigenprojs.go?s=2728:2822#L88">M_FixZeroOrRepeated</a></h2>
			<pre>func M_FixZeroOrRepeated(λ, a []<a href="/pkg/builtin/#float64">float64</a>, pert, evtol, zero <a href="/pkg/builtin/#float64">float64</a>) (haspert <a href="/pkg/builtin/#bool">bool</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_FixZeroOrRepeated computes the eigenvalues λ and applies pertubation to tensor &#39;a&#39;
if there are zero or repeated components
</p>
<pre>Note: &#39;a&#39; is modified
</pre>

			
			

		
			
			
			<h2 id="M_Inv">func <a href="/src/target/mandelops.go?s=6548:6613#L153">M_Inv</a></h2>
			<pre>func M_Inv(ai, a []<a href="/pkg/builtin/#float64">float64</a>, tol <a href="/pkg/builtin/#float64">float64</a>) (det <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_Inv computes the inverse of a 2nd order symmetric tensor &#39;a&#39;
</p>

			
			

		
			
			
			<h2 id="M_InvDeriv">func <a href="/src/target/mandelops.go?s=7552:7596#L181">M_InvDeriv</a></h2>
			<pre>func M_InvDeriv(d [][]<a href="/pkg/builtin/#float64">float64</a>, ai []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_InvDeriv computes the derivative of the inverse of a tensor with respect to itself
</p>
<pre>ai := inv(a)
d  := dai/da
</pre>

			
			

		
			
			
			<h2 id="M_LodeDeriv1">func <a href="/src/target/invariants.go?s=4584:4642#L166">M_LodeDeriv1</a></h2>
			<pre>func M_LodeDeriv1(dwdσ, σ, s []<a href="/pkg/builtin/#float64">float64</a>, p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_LodeDeriv1 computes the first derivative of w w.r.t σ
</p>
<pre>Note: only dwdσ is output
</pre>

			
			

		
			
			
			<h2 id="M_LodeDeriv2">func <a href="/src/target/invariants.go?s=5135:5216#L184">M_LodeDeriv2</a></h2>
			<pre>func M_LodeDeriv2(d2wdσdσ [][]<a href="/pkg/builtin/#float64">float64</a>, dwdσ, σ, s []<a href="/pkg/builtin/#float64">float64</a>, p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_LodeDeriv2 computes the first and second derivatives of w w.r.t. σ
</p>
<pre>Note: d2wdσdσ and dwdσ output
</pre>

			
			

		
			
			
			<h2 id="M_Norm">func <a href="/src/target/mandelops.go?s=322:354#L3">M_Norm</a></h2>
			<pre>func M_Norm(a []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_Norm calculates the norm of a 2nd order tensor represented in Mandel&#39;s basis
</p>

			
			

		
			
			
			<h2 id="M_PrincValsNum">func <a href="/src/target/eigenprojs.go?s=443:510#L7">M_PrincValsNum</a></h2>
			<pre>func M_PrincValsNum(a []<a href="/pkg/builtin/#float64">float64</a>) (λ0, λ1, λ2 <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_PrincValsNum returns the (sorted, ascending) eigenvalues of tensor &#39;a&#39; (2nd order symmetric tensor in Mandel&#39;s basis)
using Jacobi rotation.
</p>

			
			

		
			
			
			<h2 id="M_Sq">func <a href="/src/target/mandelops.go?s=1714:1739#L46">M_Sq</a></h2>
			<pre>func M_Sq(b, a []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Sq returns the square of a tensor in Mandel&#39;s representation
</p>
<pre>b = a² = a single-dot a
</pre>

			
			

		
			
			
			<h2 id="M_SqDeriv">func <a href="/src/target/mandelops.go?s=2362:2404#L64">M_SqDeriv</a></h2>
			<pre>func M_SqDeriv(d [][]<a href="/pkg/builtin/#float64">float64</a>, a []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_SqDeriv (Mandel) derivative of square of a tensor
</p>
<pre>d = derivative of a² w.r.t a
</pre>

			
			

		
			
			
			<h2 id="M_Tr">func <a href="/src/target/mandelops.go?s=629:659#L11">M_Tr</a></h2>
			<pre>func M_Tr(a []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_Tr calculates the trace a 2nd order tensor represented in Mandel&#39;s basis
</p>

			
			

		
			
			
			<h2 id="M_Ts">func <a href="/src/target/invariants.go?s=6167:6205#L216">M_Ts</a></h2>
			<pre>func M_Ts(Ts [][]<a href="/pkg/builtin/#float64">float64</a>, s []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Ts computes Ts = Psd:(ds²/ds):Psd
</p>

			
			

		
			
			
			<h2 id="M_devε">func <a href="/src/target/invariants.go?s=1833:1886#L50">M_devε</a></h2>
			<pre>func M_devε(e, ε []<a href="/pkg/builtin/#float64">float64</a>) (eno, εv, εd <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_devε returns the deviator of ε (e := dev(ε)), the norm of the deviator (eno) and the εv, εd invariants
</p>

			
			

		
			
			
			<h2 id="M_devσ">func <a href="/src/target/invariants.go?s=1466:1515#L38">M_devσ</a></h2>
			<pre>func M_devσ(s, σ []<a href="/pkg/builtin/#float64">float64</a>) (sno, p, q <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_devσ returns the deviator of σ (s := dev(σ)), the norm of the deviator (sno) and the p, q invariants
</p>

			
			

		
			
			
			<h2 id="M_oct">func <a href="/src/target/octahedral.go?s=1612:1659#L43">M_oct</a></h2>
			<pre>func M_oct(a []<a href="/pkg/builtin/#float64">float64</a>) (σa, σb, σc <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_oct computes octahedral values of a 2nd order symmetric tensor with Mandel components
</p>
<pre>Note: the (p,q,w) stress invariants are firstly computed;
      thus, it is more efficient to compute (p,q,w) first and then use &#39;PQW2O&#39;
</pre>

			
			

		
			
			
			<h2 id="M_p">func <a href="/src/target/invariants.go?s=400:430#L4">M_p</a></h2>
			<pre>func M_p(σ []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_p returns the hydrostatic pressure == negative of the mean pressure == - tr(σ) / 3
</p>

			
			

		
			
			
			<h2 id="M_pq_smp">func <a href="/src/target/invariants.go?s=9257:9332#L271">M_pq_smp</a></h2>
			<pre>func M_pq_smp(σ []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (p, q <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_pq_smp computes p and q SMP invariants of 2nd order symmetric tensor (Mandel components)
</p>
<pre>Note: 1) σ is a 2D or 3D symmetric tensor (len(σ)==4 or 6)
      2) this function creates a number of local arrays =&gt; not efficient
</pre>

			
			

		
			
			
			<h2 id="M_pqw">func <a href="/src/target/invariants.go?s=2835:2876#L90">M_pqw</a></h2>
			<pre>func M_pqw(a []<a href="/pkg/builtin/#float64">float64</a>) (p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_pqw returns p, q and w invariants
</p>

			
			

		
			
			
			<h2 id="M_pqws">func <a href="/src/target/invariants.go?s=4016:4061#L141">M_pqws</a></h2>
			<pre>func M_pqws(s, a []<a href="/pkg/builtin/#float64">float64</a>) (p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_pqws returns p, q, w invariants and the deviatoric stress s := dev(σ)
</p>

			
			

		
			
			
			<h2 id="M_pqθ">func <a href="/src/target/invariants.go?s=3383:3426#L115">M_pqθ</a></h2>
			<pre>func M_pqθ(a []<a href="/pkg/builtin/#float64">float64</a>) (p, q, θ <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_pqθ returns p, q and θ invariants
</p>

			
			

		
			
			
			<h2 id="M_q">func <a href="/src/target/invariants.go?s=522:552#L9">M_q</a></h2>
			<pre>func M_q(σ []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_q returns von Mises&#39; equivalent stress
</p>

			
			

		
			
			
			<h2 id="M_w">func <a href="/src/target/invariants.go?s=2154:2187#L62">M_w</a></h2>
			<pre>func M_w(a []<a href="/pkg/builtin/#float64">float64</a>) (w <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_w returns the Lode invariant -1 ≤ w := sin(3θ) ≤ 1
</p>

			
			

		
			
			
			<h2 id="M_εd">func <a href="/src/target/invariants.go?s=1010:1042#L26">M_εd</a></h2>
			<pre>func M_εd(ε []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_εd returns the deviatoric strain
</p>

			
			

		
			
			
			<h2 id="M_εv">func <a href="/src/target/invariants.go?s=900:932#L21">M_εv</a></h2>
			<pre>func M_εv(ε []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_εv returns the volumetric strain
</p>

			
			

		
			
			
			<h2 id="M_θ">func <a href="/src/target/invariants.go?s=2697:2735#L85">M_θ</a></h2>
			<pre>func M_θ(a []<a href="/pkg/builtin/#float64">float64</a>) (θdeg <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_θ returns the Lode invariant -30° ≤ θ := asin(w) / 3 ≤ 30°
</p>

			
			

		
			
			
			<h2 id="Man2Ten">func <a href="/src/target/tensor.go?s=6314:6364#L180">Man2Ten</a></h2>
			<pre>func Man2Ten(tensor [][]<a href="/pkg/builtin/#float64">float64</a>, mandel []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Man2Ten returns the 3x3 2nd order tensor from its Mandel representation
</p>

			
			

		
			
			
			<h2 id="Mmatch">func <a href="/src/target/fcritcoef.go?s=589:645#L8">Mmatch</a></h2>
			<pre>func Mmatch(c, φ <a href="/pkg/builtin/#float64">float64</a>, cone <a href="/pkg/builtin/#string">string</a>) (M, qy0 <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Mmatch computes M=q/p and qy0 from c and φ corresponding to the strength that would
be modelled by the Mohr-Coulomb model matching one of the following cones:
</p>
<pre>cone == &#34;cmp&#34; : compression cone (outer)
     == &#34;ext&#34; : extension cone (inner)
     == &#34;psa&#34; : plane-strain
Note: p, q, and M are Cambridge (conventional) quantities
</pre>

			
			

		
			
			
			<h2 id="NewSmpCalcμ">func <a href="/src/target/smpinvsV2.go?s=320:376#L3">NewSmpCalcμ</a></h2>
			<pre>func NewSmpCalcμ(φ, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (μ <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
NewSmpCalcμ computes μ=q/p to satisfy Mohr-Coulomb criterion @ compression
</p>

			
			

		
			
			
			<h2 id="NewSmpDerivs1">func <a href="/src/target/smpinvsV2.go?s=4882:4993#L113">NewSmpDerivs1</a></h2>
			<pre>func NewSmpDerivs1(dndλ [][]<a href="/pkg/builtin/#float64">float64</a>, dNdλ, N, F, G []<a href="/pkg/builtin/#float64">float64</a>, λ []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (m <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
NewSmpDerivs1 computes the first derivative and other variables
</p>
<pre>Note: m, dNdλ, N, F and G are output
</pre>

			
			

		
			
			
			<h2 id="NewSmpDerivs2">func <a href="/src/target/smpinvsV2.go?s=5932:6059#L142">NewSmpDerivs2</a></h2>
			<pre>func NewSmpDerivs2(d2ndλdλ [][][]<a href="/pkg/builtin/#float64">float64</a>, λ []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ, m <a href="/pkg/builtin/#float64">float64</a>, N, F, G, dNdλ []<a href="/pkg/builtin/#float64">float64</a>, dndλ [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
NewSmpDerivs2 computes the second order derivative
</p>
<pre>Note: m, N, F, G, dNdλ and dndλ are input
</pre>

			
			

		
			
			
			<h2 id="NewSmpDirector">func <a href="/src/target/smpinvsV2.go?s=922:992#L19">NewSmpDirector</a></h2>
			<pre>func NewSmpDirector(N, λ []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (m <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
NewSmpDirector computes the director (normal vector) of the spatially mobilised plane
</p>
<pre>Note: the norm of N is returned =&gt; m := norm(N)
</pre>

			
			

		
			
			
			<h2 id="NewSmpDirectorDeriv1">func <a href="/src/target/smpinvsV2.go?s=1389:1467#L29">NewSmpDirectorDeriv1</a></h2>
			<pre>func NewSmpDirectorDeriv1(dNdλ []<a href="/pkg/builtin/#float64">float64</a>, λ []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
NewSmpDirectorDeriv1 computes the first order derivative of the SMP director
</p>
<pre>Notes: Only non-zero components are returned; i.e. dNdλ[i] := dNdλ[i][i]
</pre>

			
			

		
			
			
			<h2 id="NewSmpDirectorDeriv2">func <a href="/src/target/smpinvsV2.go?s=1929:2009#L37">NewSmpDirectorDeriv2</a></h2>
			<pre>func NewSmpDirectorDeriv2(d2Ndλ2 []<a href="/pkg/builtin/#float64">float64</a>, λ []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
NewSmpDirectorDeriv2 computes the second order derivative of the SMP director
</p>
<pre>Notes: Only the non-zero components are returned; i.e.: d²Ndλ2[i] := d²N[i]/dλ[i]dλ[i]
</pre>

			
			

		
			
			
			<h2 id="NewSmpNormDirectorDeriv1">func <a href="/src/target/smpinvsV2.go?s=2512:2589#L51">NewSmpNormDirectorDeriv1</a></h2>
			<pre>func NewSmpNormDirectorDeriv1(dmdλ []<a href="/pkg/builtin/#float64">float64</a>, m <a href="/pkg/builtin/#float64">float64</a>, N, dNdλ []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
NewSmpNormDirectorDeriv1 computes the first derivative of the norm of the SMP director
</p>
<pre>Note: m, N and dNdλ are input
</pre>

			
			

		
			
			
			<h2 id="NewSmpNormDirectorDeriv2">func <a href="/src/target/smpinvsV2.go?s=2848:2975#L59">NewSmpNormDirectorDeriv2</a></h2>
			<pre>func NewSmpNormDirectorDeriv2(d2mdλdλ [][]<a href="/pkg/builtin/#float64">float64</a>, λ []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ, m <a href="/pkg/builtin/#float64">float64</a>, N, dNdλ, d2Ndλ2, dmdλ []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
NewSmpNormDirectorDeriv2 computes the second order derivative of the norm of the SMP director
</p>
<pre>Note: m, N, dNdλ, d2Ndλ2 and dmdλ are input
</pre>

			
			

		
			
			
			<h2 id="NewSmpUnitDirector">func <a href="/src/target/smpinvsV2.go?s=3431:3491#L74">NewSmpUnitDirector</a></h2>
			<pre>func NewSmpUnitDirector(n []<a href="/pkg/builtin/#float64">float64</a>, m <a href="/pkg/builtin/#float64">float64</a>, N []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
NewSmpUnitDirector computed the unit normal of the SMP
</p>
<pre>Note: m and N are input
</pre>

			
			

		
			
			
			<h2 id="NewSmpUnitDirectorDeriv1">func <a href="/src/target/smpinvsV2.go?s=3680:3766#L82">NewSmpUnitDirectorDeriv1</a></h2>
			<pre>func NewSmpUnitDirectorDeriv1(dndλ [][]<a href="/pkg/builtin/#float64">float64</a>, m <a href="/pkg/builtin/#float64">float64</a>, N, dNdλ, dmdλ []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
NewSmpUnitDirectorDeriv1 computes the first derivative of the SMP unit normal
</p>
<pre>Note: m, N, dNdλ and dmdλ are input
</pre>

			
			

		
			
			
			<h2 id="NewSmpUnitDirectorDeriv2">func <a href="/src/target/smpinvsV2.go?s=4178:4312#L96">NewSmpUnitDirectorDeriv2</a></h2>
			<pre>func NewSmpUnitDirectorDeriv2(d2ndλdλ [][][]<a href="/pkg/builtin/#float64">float64</a>, m <a href="/pkg/builtin/#float64">float64</a>, N, dNdλ, d2Ndλ2, dmdλ, n []<a href="/pkg/builtin/#float64">float64</a>, d2mdλdλ, dndλ [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
NewSmpUnitDirectorDeriv2 computes the second order derivative of the unit director of the SMP
d²n[i]/dλ[j]dλ[k]
</p>
<pre>Note: m, N, dNdλ, d2Ndλ2, dmdλ, n, d2mdλdλ and dndλ are input
</pre>

			
			

		
			
			
			<h2 id="O2L">func <a href="/src/target/octahedral.go?s=642:697#L13">O2L</a></h2>
			<pre>func O2L(σa, σb, σc <a href="/pkg/builtin/#float64">float64</a>) (σ1, σ2, σ3 <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
O2L converts octahedral values (σa,σb,σc) to principal values (σ1,σ2,σ3)
</p>

			
			

		
			
			
			<h2 id="O2Lmat">func <a href="/src/target/octahedral.go?s=905:934#L21">O2Lmat</a></h2>
			<pre>func O2Lmat() (L [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
O2Lmat computes L[I:{1,2,3}][A:{a,b,c}] = dσI/dσA =&gt; σI = L * σA
</p>

			
			

		
			
			
			<h2 id="PK1ToCauchy">func <a href="/src/target/contmech.go?s=2383:2436#L80">PK1ToCauchy</a></h2>
			<pre>func PK1ToCauchy(σ, P, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>, J <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
First Piola-Kirchhoff =&gt; Cauchy stress: σ := P * Ft / J
</p>

			
			

		
			
			
			<h2 id="PK2ToCauchy">func <a href="/src/target/contmech.go?s=3128:3181#L106">PK2ToCauchy</a></h2>
			<pre>func PK2ToCauchy(σ, S, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>, J <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Second Piola-Kirchhoff =&gt; Cauchy stress: σ := F * S * Ft / J
</p>

			
			

		
			
			
			<h2 id="PQW2O">func <a href="/src/target/octahedral.go?s=1152:1203#L30">PQW2O</a></h2>
			<pre>func PQW2O(p, q, w <a href="/pkg/builtin/#float64">float64</a>) (σa, σb, σc <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
PQW2O converts p,q,w to octahedral values (σa,σb,σc)
</p>

			
			

		
			
			
			<h2 id="Phi2M">func <a href="/src/target/fcritcoef.go?s=1348:1390#L34">Phi2M</a></h2>
			<pre>func Phi2M(φ <a href="/pkg/builtin/#float64">float64</a>, typ <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Phi2M calculates M = max q/p at compression (φ: friction angle at compression (degrees)).
type = {&#34;oct&#34;, &#34;cam&#34;, &#34;smp&#34;}
</p>

			
			

		
			
			
			<h2 id="PlotOct">func <a href="/src/target/octahedral.go?s=5051:5251#L119">PlotOct</a></h2>
			<pre>func PlotOct(filename <a href="/pkg/builtin/#string">string</a>, σcCte, rmin, rmax <a href="/pkg/builtin/#float64">float64</a>, nr, nα <a href="/pkg/builtin/#int">int</a>, φ <a href="/pkg/builtin/#float64">float64</a>, F <a href="#Cb_F_t">Cb_F_t</a>, G <a href="#Cb_G_t">Cb_G_t</a>,
    notpolarc, simplec, only0, grads, showpts, first, last <a href="/pkg/builtin/#bool">bool</a>, ferr <a href="/pkg/builtin/#float64">float64</a>, args ...interface{})</pre>
			<p>
PlotOct plots a function cross-section and gradients projections on octahedral plane
</p>

			
			

		
			
			
			<h2 id="PlotRefOct">func <a href="/src/target/octahedral.go?s=4105:4157#L95">PlotRefOct</a></h2>
			<pre>func PlotRefOct(φ, σc <a href="/pkg/builtin/#float64">float64</a>, withExtCircle <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
PlotRefOct plots reference failure criterions in octahedral plane:
</p>
<pre>Drucker-Prager and Mohr-Circles
</pre>

			
			

		
			
			
			<h2 id="PlotRosette">func <a href="/src/target/octahedral.go?s=1786:1857#L50">PlotRosette</a></h2>
			<pre>func PlotRosette(r <a href="/pkg/builtin/#float64">float64</a>, full, ref <a href="/pkg/builtin/#bool">bool</a>, withtext <a href="/pkg/builtin/#bool">bool</a>, fsz <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
PlotRosette plots rosette in octahedral plane
</p>

			
			

		
			
			
			<h2 id="PullBack">func <a href="/src/target/contmech.go?s=3931:3971#L134">PullBack</a></h2>
			<pre>func PullBack(res, a, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Pull-back (type A/cov): res := push-back(a) = Ft * a * F
</p>

			
			

		
			
			
			<h2 id="PullBackB">func <a href="/src/target/contmech.go?s=4724:4765#L162">PullBackB</a></h2>
			<pre>func PullBackB(res, a, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Pull-back (type B/contra): res := pull-back(a) = inv(F) * a * inv(F)^t
</p>

			
			

		
			
			
			<h2 id="PushForward">func <a href="/src/target/contmech.go?s=3543:3586#L120">PushForward</a></h2>
			<pre>func PushForward(res, a, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Push-forward (type A/cov): res := push-forward(a) = inv(F)^t * a * inv(F)
</p>

			
			

		
			
			
			<h2 id="PushForwardB">func <a href="/src/target/contmech.go?s=4323:4367#L148">PushForwardB</a></h2>
			<pre>func PushForwardB(res, a, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Push-forward (type B/contra): res := push-forward(a) = F * a * Ft
</p>

			
			

		
			
			
			<h2 id="RightCauchyGreenDef">func <a href="/src/target/contmech.go?s=292:334#L1">RightCauchyGreenDef</a></h2>
			<pre>func RightCauchyGreenDef(C, F [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Right Cauchy-Green deformation tensor: C := Ft * F
Symmetric and positive definite: det(C) = det(F)^2
</p>

			
			

		
			
			
			<h2 id="SMPderivs1">func <a href="/src/target/generalinvs.go?s=5272:5363#L145">SMPderivs1</a></h2>
			<pre>func SMPderivs1(dpdλ, dqdλ, λ []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (p, q <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
SMPderivs1 computes the 1st order derivatives of SMP invariants
</p>
<pre>Note: internal variables are created =&gt; not efficient
</pre>

			
			

		
			
			
			<h2 id="SMPinvs">func <a href="/src/target/generalinvs.go?s=4881:4955#L135">SMPinvs</a></h2>
			<pre>func SMPinvs(λ []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (p, q <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
SMPinvs computes the SMP invariants, after the internal computation of the SMP unit director
</p>
<pre>Note: internal variables are created =&gt; not efficient
</pre>

			
			

		
			
			
			<h2 id="ShiftedEigenvs">func <a href="/src/target/generalinvs.go?s=443:513#L6">ShiftedEigenvs</a></h2>
			<pre>func ShiftedEigenvs(λ, λbar []<a href="/pkg/builtin/#float64">float64</a>, λc, tol <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
ShiftedEigenvs computes the positive and shifted eigenvalues of a second order tensor
Note: λbar are the eigenvalues of the tensor
</p>
<pre>λc is a positive value
</pre>

			
			

		
			
			
			<h2 id="SmpCalcμ">func <a href="/src/target/smpinvsV1.go?s=284:326#L2">SmpCalcμ</a></h2>
			<pre>func SmpCalcμ(φ, b <a href="/pkg/builtin/#float64">float64</a>) (μ <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpCalcμ computes μ=q/p to satisfy Mohr-Coulomb criterion @ compression
</p>

			
			

		
			
			
			<h2 id="SmpCalcμNum">func <a href="/src/target/smpinvsV1.go?s=555:600#L9">SmpCalcμNum</a></h2>
			<pre>func SmpCalcμNum(φ, b <a href="/pkg/builtin/#float64">float64</a>) (μ <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpCalcμNum computes μ=q/p to satisfy Mohr-Coulomb criterion @ compression
</p>

			
			

		
			
			
			<h2 id="SmpDerivs">func <a href="/src/target/smpinvsV1.go?s=4626:4717#L119">SmpDerivs</a></h2>
			<pre>func SmpDerivs(d2mdσdσ, dndσ [][]<a href="/pkg/builtin/#float64">float64</a>, dmdσ, n, σ []<a href="/pkg/builtin/#float64">float64</a>, b <a href="/pkg/builtin/#float64">float64</a>) (m <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpDerivs computes the SMP director and its first order derivative. In addition, the
norm of the SMP director (m) and its first and second order derivatives are computed.
</p>

			
			

		
			
			
			<h2 id="SmpDirector">func <a href="/src/target/smpinvsV1.go?s=1124:1168#L24">SmpDirector</a></h2>
			<pre>func SmpDirector(N, σ []<a href="/pkg/builtin/#float64">float64</a>, b <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpDirector computes the director (normal vector) of the spatially mobilised plane
Note: σ are the shifted and positive eigenvalues of the tensor, i.e:
σ = {-λ0+σc, -λ1+σc, -λ2+σc}
</p>

			
			

		
			
			
			<h2 id="SmpDirectorDeriv1">func <a href="/src/target/smpinvsV1.go?s=1326:1392#L31">SmpDirectorDeriv1</a></h2>
			<pre>func SmpDirectorDeriv1(dNdσ [][]<a href="/pkg/builtin/#float64">float64</a>, σ []<a href="/pkg/builtin/#float64">float64</a>, b <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpDirectorDeriv1 computes the first order derivative of the SMP director
</p>

			
			

		
			
			
			<h2 id="SmpDirectorDeriv2">func <a href="/src/target/smpinvsV1.go?s=1705:1779#L44">SmpDirectorDeriv2</a></h2>
			<pre>func SmpDirectorDeriv2(i, j, k <a href="/pkg/builtin/#int">int</a>, σ []<a href="/pkg/builtin/#float64">float64</a>, b <a href="/pkg/builtin/#float64">float64</a>) (res <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpDirectorDeriv2 computes the second order derivative of the SMP director
d²N[i]/dσ[j]dσ[k]
</p>

			
			

		
			
			
			<h2 id="SmpNormDirectorDeriv1">func <a href="/src/target/smpinvsV1.go?s=2075:2155#L54">SmpNormDirectorDeriv1</a></h2>
			<pre>func SmpNormDirectorDeriv1(dmdσ []<a href="/pkg/builtin/#float64">float64</a>, σ []<a href="/pkg/builtin/#float64">float64</a>, b <a href="/pkg/builtin/#float64">float64</a>) (m <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpNormDirectorDeriv1 computes the first derivative of the norm of the SMP director
</p>

			
			

		
			
			
			<h2 id="SmpNormDirectorDeriv2">func <a href="/src/target/smpinvsV1.go?s=2454:2548#L63">SmpNormDirectorDeriv2</a></h2>
			<pre>func SmpNormDirectorDeriv2(d2mdσdσ [][]<a href="/pkg/builtin/#float64">float64</a>, σ []<a href="/pkg/builtin/#float64">float64</a>, b, m <a href="/pkg/builtin/#float64">float64</a>, dmdσ []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpNormDirectorDeriv2 computes the second order derivative of the norm of the SMP director
</p>

			
			

		
			
			
			<h2 id="SmpUnitDirector">func <a href="/src/target/smpinvsV1.go?s=3177:3237#L83">SmpUnitDirector</a></h2>
			<pre>func SmpUnitDirector(n, σ []<a href="/pkg/builtin/#float64">float64</a>, b <a href="/pkg/builtin/#float64">float64</a>) (m <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpUnitDirector computed the unit normal of the SMP
Note: σ are the shifted and positive eigenvalues of the tensor, i.e:
σ = {-λ0+σc, -λ1+σc, -λ2+σc}
m = norm(N)
</p>

			
			

		
			
			
			<h2 id="SmpUnitDirectorDeriv1">func <a href="/src/target/smpinvsV1.go?s=3501:3594#L92">SmpUnitDirectorDeriv1</a></h2>
			<pre>func SmpUnitDirectorDeriv1(dndσ [][]<a href="/pkg/builtin/#float64">float64</a>, σ, n []<a href="/pkg/builtin/#float64">float64</a>, b, m <a href="/pkg/builtin/#float64">float64</a>, dmdσ []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpUnitDirectorDeriv1 computes the first derivative of the SMP unit normal
</p>

			
			

		
			
			
			<h2 id="SmpUnitDirectorDeriv2">func <a href="/src/target/smpinvsV1.go?s=3946:4065#L105">SmpUnitDirectorDeriv2</a></h2>
			<pre>func SmpUnitDirectorDeriv2(d2ndσdσ [][][]<a href="/pkg/builtin/#float64">float64</a>, σ, n, dmdσ []<a href="/pkg/builtin/#float64">float64</a>, b, m <a href="/pkg/builtin/#float64">float64</a>, d2mdσdσ, dndσ [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpUnitDirectorDeriv2 computes the second order derivative of the unit director of the SMP
d²n[i]/dσ[j]dσ[k]
</p>

			
			

		
			
			
			<h2 id="Ten2Man">func <a href="/src/target/tensor.go?s=7129:7179#L196">Ten2Man</a></h2>
			<pre>func Ten2Man(mandel []<a href="/pkg/builtin/#float64">float64</a>, tensor [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Ten2Man returns the Mandel representation of a 3x3 2nd order tensor
</p>

			
			

		
			
			
			<h2 id="Tr">func <a href="/src/target/operators.go?s=284:314#L4">Tr</a></h2>
			<pre>func Tr(a [][]<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Tr returns the trace of a second order tensor
</p>

			
			

		
		
			
			
			<h2 id="Cb_F_t">type <a href="/src/target/octahedral.go?s=4802:4878#L115">Cb_F_t</a></h2>
			<pre>type Cb_F_t func(A []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (fval <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="Cb_G_t">type <a href="/src/target/octahedral.go?s=4879:4961#L116">Cb_G_t</a></h2>
			<pre>type Cb_G_t func(dfdA, A []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (fval <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="Cb_isofun_f">type <a href="/src/target/isofun.go?s=351:415#L6">Cb_isofun_f</a></h2>
			<pre>type Cb_isofun_f func(p, q <a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Callbacks
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Cb_isofun_g">type <a href="/src/target/isofun.go?s=416:493#L7">Cb_isofun_g</a></h2>
			<pre>type Cb_isofun_g func(p, q <a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (dfdp, dfdq <a href="/pkg/builtin/#float64">float64</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="Cb_isofun_h">type <a href="/src/target/isofun.go?s=494:584#L8">Cb_isofun_h</a></h2>
			<pre>type Cb_isofun_h func(p, q <a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (d2fdp2, d2fdq2, d2fdpdq <a href="/pkg/builtin/#float64">float64</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="IsoFun">type <a href="/src/target/isofun.go?s=646:2532#L11">IsoFun</a></h2>
			<pre>type IsoFun struct {

    <span class="comment">// eigenvalues/projectors</span>
    FixRep <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// do run perturbation code to fix repeated eigenvalues</span>
    HasRep <a href="/pkg/builtin/#bool">bool</a>        <span class="comment">// has repeated eigenvalues</span>
    Pert   <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// perturbation values</span>
    EvTol  <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// tolerance to detect repeated eigenvalues</span>
    Zero   <a href="/pkg/builtin/#float64">float64</a>     <span class="comment">// minimum λ to be considered zero</span>
    L, Ls  []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// eigenvalues and shifted eigenvalues</span>
    P      [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// eigenprojectors</span>

    N          []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// SMP director and unit director</span>
    Frmp, Grmp []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// ramp function values</span>

    Dfdλ []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// first derivative of f</span>
    <span class="comment">// for second derivatives</span>
    Acpy []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// copy of tensor &#39;A&#39;</span>

    Dgdλ [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// second derivative of f</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
IsoFun handles isotropic functions and their derivatives
</p>


			

			

			
			
			

			

			
				
				<h3 id="IsoFun.ApplyPert">func (*IsoFun) <a href="/src/target/isofun.go?s=6842:6893#L184">ApplyPert</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) ApplyPert(A []<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
ApplyPert computes eigenvalues of A and applies a perturbation to avoid repeated eigenvalues
</p>
<pre>Notes:
 1) &#39;A&#39; is modified
 2) eigenvalues are stored in L
 3) HasRep indicates that there were repeated eigenvalues
</pre>

				
				
				
			
				
				<h3 id="IsoFun.CheckGrads">func (*IsoFun) <a href="/src/target/isofun.go?s=15927:15996#L499">CheckGrads</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) CheckGrads(A []<a href="/pkg/builtin/#float64">float64</a>, tol, tol2 <a href="/pkg/builtin/#float64">float64</a>, ver <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
CheckGrads check df/dA and d²f/dA²
</p>

				
				
				
			
				
				<h3 id="IsoFun.DebugOutput">func (*IsoFun) <a href="/src/target/isofun.go?s=18061:18105#L574">DebugOutput</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) DebugOutput(princOnly <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
DebugOutput outputs debug information
</p>

				
				
				
			
				
				<h3 id="IsoFun.Fa">func (*IsoFun) <a href="/src/target/isofun.go?s=7068:7146#L190">Fa</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Fa(A []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Fa evaluates the isotropic function @ A (a second order tensor in Mandel&#39;s basis)
</p>

				
				
				
			
				
				<h3 id="IsoFun.FindIntersect">func (*IsoFun) <a href="/src/target/isofun.go?s=10190:10312#L292">FindIntersect</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) FindIntersect(p0, k <a href="/pkg/builtin/#float64">float64</a>, Δλ []<a href="/pkg/builtin/#float64">float64</a>, usek, debug <a href="/pkg/builtin/#bool">bool</a>, args ...interface{}) (λ_at_int []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
FindIntersect find point on surface using Newton&#39;s method
</p>

				
				
				
			
				
				<h3 id="IsoFun.Fp">func (*IsoFun) <a href="/src/target/isofun.go?s=4114:4193#L99">Fp</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Fp(λ []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Fp evaluates the isotropic function @ λ (principal values)
</p>

				
				
				
			
				
				<h3 id="IsoFun.Ga">func (*IsoFun) <a href="/src/target/isofun.go?s=7635:7720#L212">Ga</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Ga(dfdA, A []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (fval <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ga computes f and dfdA @ A (a second order tensor in Mandel&#39;s basis)
</p>
<pre>Notes:
 1) eigenvalues are stored in L and eigenprojectors are stored in P
 2) Dfdλ is calculated and is availabe for external use
</pre>

				
				
				
			
				
				<h3 id="IsoFun.Get_bsmp">func (*IsoFun) <a href="/src/target/isofun.go?s=2547:2582#L52">Get_bsmp</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Get_bsmp() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Accessors
</p>

				
				
				
			
				
				<h3 id="IsoFun.Get_derivs_afterHa">func (*IsoFun) <a href="/src/target/isofun.go?s=9483:9542#L275">Get_derivs_afterHa</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Get_derivs_afterHa(dpdσ, dqdσ []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Get_derivs_afterHa returns the derivatives of SMP invariants after a call to HafterGa
</p>

				
				
				
			
				
				<h3 id="IsoFun.Get_pq">func (*IsoFun) <a href="/src/target/isofun.go?s=2648:2688#L54">Get_pq</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Get_pq() (p, q <a href="/pkg/builtin/#float64">float64</a>)</pre>
				
				
				
				
			
				
				<h3 id="IsoFun.Gp">func (*IsoFun) <a href="/src/target/isofun.go?s=4734:4814#L123">Gp</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Gp(λ []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (fval <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Gp computes f and Dfdλ @ λ (principal values)
Notes:
</p>
<pre>1) λ is input =&gt; shifted and copied into to internal Ls for use in Hp
2) output is stored in Dfdλ
</pre>

				
				
				
			
				
				<h3 id="IsoFun.HafterGa">func (*IsoFun) <a href="/src/target/isofun.go?s=8422:8501#L248">HafterGa</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) HafterGa(d2fdAdA [][]<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
HafterGa computes d2fdada after G is called
</p>
<pre>Notes:
 1) Dgdλ==d2fdλdλ is calculated and is availabe for external use
</pre>

				
				
				
			
				
				<h3 id="IsoFun.HafterGp">func (*IsoFun) <a href="/src/target/isofun.go?s=5679:5737#L154">HafterGp</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) HafterGp(args ...interface{}) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
HafterGp computes d2fdλdλ == dgdλ after Gp was called
Notes:
</p>
<pre>1) output is stored in Dgdλ
</pre>

				
				
				
			
				
				<h3 id="IsoFun.Init">func (*IsoFun) <a href="/src/target/isofun.go?s=2763:2876#L57">Init</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Init(a, b, β, ϵ, shift <a href="/pkg/builtin/#float64">float64</a>, ncp <a href="/pkg/builtin/#int">int</a>, ffcn <a href="#Cb_isofun_f">Cb_isofun_f</a>, gfcn <a href="#Cb_isofun_g">Cb_isofun_g</a>, hfcn <a href="#Cb_isofun_h">Cb_isofun_h</a>)</pre>
				<p>
Init initialises the isotropic function structure
</p>

				
				
				
			
				
				<h3 id="IsoFun.Set_bsmp">func (*IsoFun) <a href="/src/target/isofun.go?s=2599:2635#L53">Set_bsmp</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Set_bsmp(b <a href="/pkg/builtin/#float64">float64</a>)</pre>
				
				
				
				
			
				
				<h3 id="IsoFun.String">func (*IsoFun) <a href="/src/target/isofun.go?s=17812:17848#L566">String</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) String() (l <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
String returns information of this object
</p>

				
				
				
			
				
				<h3 id="IsoFun.View">func (*IsoFun) <a href="/src/target/isofun.go?s=14421:14552#L439">View</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) View(l <a href="/pkg/builtin/#float64">float64</a>, λ []<a href="/pkg/builtin/#float64">float64</a>, grads <a href="/pkg/builtin/#bool">bool</a>, gradsFtol <a href="/pkg/builtin/#float64">float64</a>, extraconf func(is *<a href="/pkg/code.google.com/p/gosl/vtk/">vtk</a>.<a href="/pkg/code.google.com/p/gosl/vtk/#IsoSurf">IsoSurf</a>), args ...interface{})</pre>
				<p>
View visualises the isosurface with VTK
</p>

				
				
				
			
		
			
			
			<h2 id="NcteM">type <a href="/src/target/nonctem.go?s=312:464#L3">NcteM</a></h2>
			<pre>type NcteM struct {
    Mfix <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// derived</span>
    Sinφ <a href="/pkg/builtin/#float64">float64</a>
    Tanφ <a href="/pkg/builtin/#float64">float64</a>
    Mcs  <a href="/pkg/builtin/#float64">float64</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
NcteM implements Argyris-Sheng et al M(w) non-constant M coefficient
</p>


			

			

			
			
			

			

			
				
				<h3 id="NcteM.D2Mdw2">func (*NcteM) <a href="/src/target/nonctem.go?s=1603:1644#L54">D2Mdw2</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) D2Mdw2(w <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
D2Mdw2 implements d²M/dw²
</p>

				
				
				
			
				
				<h3 id="NcteM.DMdw">func (*NcteM) <a href="/src/target/nonctem.go?s=1408:1447#L46">DMdw</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) DMdw(w <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
DMdw implements dM/dw
</p>

				
				
				
			
				
				<h3 id="NcteM.Deriv1">func (*NcteM) <a href="/src/target/nonctem.go?s=1895:1958#L64">Deriv1</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) Deriv1(dMdσ, σ, s []<a href="/pkg/builtin/#float64">float64</a>, p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Deriv1 returns the first derivative of M w.r.t σ
</p>
<pre>Note: only dMdσ is output
</pre>

				
				
				
			
				
				<h3 id="NcteM.Deriv2">func (*NcteM) <a href="/src/target/nonctem.go?s=2323:2409#L80">Deriv2</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) Deriv2(d2Mdσdσ [][]<a href="/pkg/builtin/#float64">float64</a>, dMdσ, σ, s []<a href="/pkg/builtin/#float64">float64</a>, p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Deriv2 returns the first and second derivatives of M w.r.t σ
</p>
<pre>Note: d2Mdσdσ and dMdσ output
</pre>

				
				
				
			
				
				<h3 id="NcteM.Init">func (*NcteM) <a href="/src/target/nonctem.go?s=498:549#L15">Init</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) Init(prms []<a href="/pkg/builtin/#string">string</a>, vals []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Init initialises this object
</p>

				
				
				
			
				
				<h3 id="NcteM.M">func (*NcteM) <a href="/src/target/nonctem.go?s=1214:1250#L38">M</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) M(w <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
M implements M(w)
</p>

				
				
				
			
				
				<h3 id="NcteM.String">func (*NcteM) <a href="/src/target/nonctem.go?s=1085:1120#L33">String</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) String() (s <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
String returns a string representing this structure
</p>

				
				
				
			
		
	

	





</div><!-- page -->
<div id="footer">
<br /><br />
<hr>
<pre class="copyright">
Copyright (c) 2012 Dorival de Moraes Pedroso. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
   * Neither the name of Dorival M Pedroso nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre><!-- copyright -->
</div><!-- footer -->
</body>
</html>
