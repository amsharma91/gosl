<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">
<title>Gosl &ndash; package tsr</title>
<link type="text/css" rel="stylesheet" href="static/style.css">
<script type="text/javascript" src="static/godocs.js"></script>
<style type="text/css"></style>
</head>
<body>
<div id="page" class=\wide">
<div class="container">
<h1>Gosl &ndash; <b>tsr</b> &ndash; tensor algebra and definitions for continuum mechanics</h1>
use 'godoc cmd/github.com/cpmech/gosl/tsr' for documentation on the github.com/cpmech/gosl/tsr command 

<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type='text/javascript'>
	document.ANALYSIS_DATA = ;
	document.CALLGRAPH = ;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/cpmech/gosl/tsr"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
tsr implements routines to conduct tensor operations
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#Add">func Add(u [][]float64, α float64, a [][]float64, β float64, b [][]float64)</a></dd>
			
				
				<dd><a href="#Alloc2">func Alloc2() (tensor [][]float64)</a></dd>
			
				
				<dd><a href="#Alloc4">func Alloc4() (tensor [][][][]float64)</a></dd>
			
				
				<dd><a href="#AlmansiStrain">func AlmansiStrain(e, Fi [][]float64)</a></dd>
			
				
				<dd><a href="#CauchyToPK1">func CauchyToPK1(P, σ, F, Fi [][]float64, J float64)</a></dd>
			
				
				<dd><a href="#CauchyToPK2">func CauchyToPK2(S, σ, F, Fi [][]float64, J float64)</a></dd>
			
				
				<dd><a href="#CheckEigenprojs">func CheckEigenprojs(a []float64, tolP, tolS float64, ver bool) (λsorted []float64)</a></dd>
			
				
				<dd><a href="#CheckEigenprojsDerivs">func CheckEigenprojsDerivs(a []float64, tol float64, ver bool, zero float64)</a></dd>
			
				
				<dd><a href="#Det">func Det(a [][]float64) float64</a></dd>
			
				
				<dd><a href="#Dev">func Dev(a [][]float64) (deva [][]float64)</a></dd>
			
				
				<dd><a href="#GenInvs">func GenInvs(L, n []float64, a float64) (p, q float64, err error)</a></dd>
			
				
				<dd><a href="#GenInvsDeriv1">func GenInvsDeriv1(dpdL, dqdL []float64, L, n []float64, dndL [][]float64, a float64) (p, q float64, err error)</a></dd>
			
				
				<dd><a href="#GenInvsDeriv2">func GenInvsDeriv2(d2pdLdL, d2qdLdL [][]float64, L, n, dpdL, dqdL []float64, p, q float64, dndL [][]float64, d2ndLdL [][][]float64, a float64)</a></dd>
			
				
				<dd><a href="#GenTvec">func GenTvec(t, L, n []float64)</a></dd>
			
				
				<dd><a href="#GenTvecDeriv1">func GenTvecDeriv1(dtdL [][]float64, L, n []float64, dndL [][]float64)</a></dd>
			
				
				<dd><a href="#GenTvecDeriv2">func GenTvecDeriv2(i, j, k int, L []float64, dndL [][]float64, d2ndLdL_ijk float64) (res float64)</a></dd>
			
				
				<dd><a href="#GreenStrain">func GreenStrain(E, F [][]float64)</a></dd>
			
				
				<dd><a href="#Inv">func Inv(ai, a [][]float64) (det float64, err error)</a></dd>
			
				
				<dd><a href="#L2O">func L2O(σ1, σ2, σ3 float64) (σa, σb, σc float64)</a></dd>
			
				
				<dd><a href="#L_strains">func L_strains(ε []float64) (εv, εd float64)</a></dd>
			
				
				<dd><a href="#LeftCauchyGreenDef">func LeftCauchyGreenDef(b, F [][]float64)</a></dd>
			
				
				<dd><a href="#LinStrain">func LinStrain(ε, F [][]float64)</a></dd>
			
				
				<dd><a href="#M2Phi">func M2Phi(M float64, typ string) float64</a></dd>
			
				
				<dd><a href="#M2T">func M2T(mandel []float64, i, j int) (component float64)</a></dd>
			
				
				<dd><a href="#M2TT">func M2TT(mandel [][]float64, i, j, k, l int) float64</a></dd>
			
				
				<dd><a href="#M_Alloc2">func M_Alloc2(ndim int) (a []float64)</a></dd>
			
				
				<dd><a href="#M_Alloc4">func M_Alloc4(ndim int) (A [][]float64)</a></dd>
			
				
				<dd><a href="#M_AllocEigenprojs">func M_AllocEigenprojs(ncp int) (P [][]float64)</a></dd>
			
				
				<dd><a href="#M_CharInvs">func M_CharInvs(a []float64) (I1, I2, I3 float64)</a></dd>
			
				
				<dd><a href="#M_CharInvsAndDerivs">func M_CharInvsAndDerivs(a []float64) (I1, I2, I3 float64, dI1da, dI2da, dI3da []float64)</a></dd>
			
				
				<dd><a href="#M_Det">func M_Det(a []float64) float64</a></dd>
			
				
				<dd><a href="#M_DetDeriv">func M_DetDeriv(d, a []float64)</a></dd>
			
				
				<dd><a href="#M_Dev">func M_Dev(a []float64) (s []float64)</a></dd>
			
				
				<dd><a href="#M_Dot">func M_Dot(c []float64, a, b []float64, nonsymTol float64) (err error)</a></dd>
			
				
				<dd><a href="#M_Dy">func M_Dy(a, b []float64) (c [][]float64)</a></dd>
			
				
				<dd><a href="#M_DyAdd">func M_DyAdd(c [][]float64, s float64, a, b []float64)</a></dd>
			
				
				<dd><a href="#M_EigenProjsDerivAna">func M_EigenProjsDerivAna(dPda [][][]float64, a, λ []float64, P [][]float64) (err error)</a></dd>
			
				
				<dd><a href="#M_EigenProjsDerivAuto">func M_EigenProjsDerivAuto(dPda [][][]float64, a, λ []float64, P [][]float64) (err error)</a></dd>
			
				
				<dd><a href="#M_EigenProjsDerivNum">func M_EigenProjsDerivNum(dPda [][][]float64, a []float64, h float64) (err error)</a></dd>
			
				
				<dd><a href="#M_EigenValsNum">func M_EigenValsNum(λ, a []float64) (err error)</a></dd>
			
				
				<dd><a href="#M_EigenValsProjsNum">func M_EigenValsProjsNum(P [][]float64, λ, a []float64) (err error)</a></dd>
			
				
				<dd><a href="#M_EigenValsVecsNum">func M_EigenValsVecsNum(Q [][]float64, λ, a []float64) (err error)</a></dd>
			
				
				<dd><a href="#M_Inv">func M_Inv(ai, a []float64, tol float64) (det float64, err error)</a></dd>
			
				
				<dd><a href="#M_InvDeriv">func M_InvDeriv(d [][]float64, ai []float64)</a></dd>
			
				
				<dd><a href="#M_LodeDeriv1">func M_LodeDeriv1(dwdσ, σ, s []float64, p, q, w float64)</a></dd>
			
				
				<dd><a href="#M_LodeDeriv2">func M_LodeDeriv2(d2wdσdσ [][]float64, dwdσ, σ, s []float64, p, q, w float64)</a></dd>
			
				
				<dd><a href="#M_Norm">func M_Norm(a []float64) float64</a></dd>
			
				
				<dd><a href="#M_PrincValsNum">func M_PrincValsNum(a []float64) (λ0, λ1, λ2 float64, err error)</a></dd>
			
				
				<dd><a href="#M_Sq">func M_Sq(b, a []float64)</a></dd>
			
				
				<dd><a href="#M_SqDeriv">func M_SqDeriv(d [][]float64, a []float64)</a></dd>
			
				
				<dd><a href="#M_Tr">func M_Tr(a []float64) float64</a></dd>
			
				
				<dd><a href="#M_Ts">func M_Ts(Ts [][]float64, s []float64)</a></dd>
			
				
				<dd><a href="#M_devε">func M_devε(e, ε []float64) (eno, εv, εd float64)</a></dd>
			
				
				<dd><a href="#M_devσ">func M_devσ(s, σ []float64) (sno, p, q float64)</a></dd>
			
				
				<dd><a href="#M_oct">func M_oct(a []float64) (σa, σb, σc float64)</a></dd>
			
				
				<dd><a href="#M_p">func M_p(σ []float64) float64</a></dd>
			
				
				<dd><a href="#M_pq_smp">func M_pq_smp(σ []float64, a, b, β, ϵ float64) (p, q float64, err error)</a></dd>
			
				
				<dd><a href="#M_pqw">func M_pqw(a []float64) (p, q, w float64)</a></dd>
			
				
				<dd><a href="#M_pqws">func M_pqws(s, a []float64) (p, q, w float64)</a></dd>
			
				
				<dd><a href="#M_pqθ">func M_pqθ(a []float64) (p, q, θ float64)</a></dd>
			
				
				<dd><a href="#M_q">func M_q(σ []float64) float64</a></dd>
			
				
				<dd><a href="#M_w">func M_w(a []float64) (w float64)</a></dd>
			
				
				<dd><a href="#M_εd">func M_εd(ε []float64) float64</a></dd>
			
				
				<dd><a href="#M_εv">func M_εv(ε []float64) float64</a></dd>
			
				
				<dd><a href="#M_θ">func M_θ(a []float64) (θdeg float64)</a></dd>
			
				
				<dd><a href="#Man2Ten">func Man2Ten(tensor [][]float64, mandel []float64)</a></dd>
			
				
				<dd><a href="#Mmatch">func Mmatch(c, φ float64, cone string) (M, qy0 float64)</a></dd>
			
				
				<dd><a href="#O2L">func O2L(σa, σb, σc float64) (σ1, σ2, σ3 float64)</a></dd>
			
				
				<dd><a href="#O2Lmat">func O2Lmat() (L [][]float64)</a></dd>
			
				
				<dd><a href="#PK1ToCauchy">func PK1ToCauchy(σ, P, F, Fi [][]float64, J float64)</a></dd>
			
				
				<dd><a href="#PK2ToCauchy">func PK2ToCauchy(σ, S, F, Fi [][]float64, J float64)</a></dd>
			
				
				<dd><a href="#PQW2O">func PQW2O(p, q, w float64) (σa, σb, σc float64)</a></dd>
			
				
				<dd><a href="#Phi2M">func Phi2M(φ float64, typ string) float64</a></dd>
			
				
				<dd><a href="#PlotOct">func PlotOct(filename string, σcCte, rmin, rmax float64, nr, nα int, φ float64, F Cb_F_t, G Cb_G_t, notpolarc, simplec, only0, grads, showpts, first, last bool, ferr float64, args ...interface{})</a></dd>
			
				
				<dd><a href="#PlotRefOct">func PlotRefOct(φ, σc float64, withExtCircle bool)</a></dd>
			
				
				<dd><a href="#PlotRosette">func PlotRosette(r float64, full, ref bool, withtext bool, fsz float64)</a></dd>
			
				
				<dd><a href="#PullBack">func PullBack(res, a, F, Fi [][]float64)</a></dd>
			
				
				<dd><a href="#PullBackB">func PullBackB(res, a, F, Fi [][]float64)</a></dd>
			
				
				<dd><a href="#PushForward">func PushForward(res, a, F, Fi [][]float64)</a></dd>
			
				
				<dd><a href="#PushForwardB">func PushForwardB(res, a, F, Fi [][]float64)</a></dd>
			
				
				<dd><a href="#RightCauchyGreenDef">func RightCauchyGreenDef(C, F [][]float64)</a></dd>
			
				
				<dd><a href="#SMPderivs1">func SMPderivs1(dpdL, dqdL, L []float64, a, b, β, ϵ float64) (p, q float64, err error)</a></dd>
			
				
				<dd><a href="#SMPinvs">func SMPinvs(L []float64, a, b, β, ϵ float64) (p, q float64, err error)</a></dd>
			
				
				<dd><a href="#SmpCalcμ">func SmpCalcμ(φ, a, b, β, ϵ float64) (μ float64)</a></dd>
			
				
				<dd><a href="#SmpDerivs1">func SmpDerivs1(dndL [][]float64, dNdL, N, F, G []float64, L []float64, a, b, β, ϵ float64) (m float64)</a></dd>
			
				
				<dd><a href="#SmpDerivs2">func SmpDerivs2(d2ndLdL [][][]float64, L []float64, a, b, β, ϵ, m float64, N, F, G, dNdL []float64, dndL [][]float64)</a></dd>
			
				
				<dd><a href="#SmpDirector">func SmpDirector(N, L []float64, a, b, β, ϵ float64) (m float64)</a></dd>
			
				
				<dd><a href="#SmpDirectorDeriv1">func SmpDirectorDeriv1(dNdL []float64, L []float64, a, b, β, ϵ float64)</a></dd>
			
				
				<dd><a href="#SmpDirectorDeriv2">func SmpDirectorDeriv2(d2NdL2 []float64, L []float64, a, b, β, ϵ float64)</a></dd>
			
				
				<dd><a href="#SmpNormDirectorDeriv1">func SmpNormDirectorDeriv1(dmdL []float64, m float64, N, dNdL []float64)</a></dd>
			
				
				<dd><a href="#SmpNormDirectorDeriv2">func SmpNormDirectorDeriv2(d2mdLdL [][]float64, L []float64, a, b, β, ϵ, m float64, N, dNdL, d2NdL2, dmdL []float64)</a></dd>
			
				
				<dd><a href="#SmpUnitDirector">func SmpUnitDirector(n []float64, m float64, N []float64)</a></dd>
			
				
				<dd><a href="#SmpUnitDirectorDeriv1">func SmpUnitDirectorDeriv1(dndL [][]float64, m float64, N, dNdL, dmdL []float64)</a></dd>
			
				
				<dd><a href="#SmpUnitDirectorDeriv2">func SmpUnitDirectorDeriv2(d2ndLdL [][][]float64, m float64, N, dNdL, d2NdL2, dmdL, n []float64, d2mdLdL, dndL [][]float64)</a></dd>
			
				
				<dd><a href="#Ten2Man">func Ten2Man(mandel []float64, tensor [][]float64)</a></dd>
			
				
				<dd><a href="#Tr">func Tr(a [][]float64) float64</a></dd>
			
			
				
				<dd><a href="#Cb_F_t">type Cb_F_t</a></dd>
				
				
			
				
				<dd><a href="#Cb_G_t">type Cb_G_t</a></dd>
				
				
			
				
				<dd><a href="#Cb_isofun_f">type Cb_isofun_f</a></dd>
				
				
			
				
				<dd><a href="#Cb_isofun_g">type Cb_isofun_g</a></dd>
				
				
			
				
				<dd><a href="#Cb_isofun_h">type Cb_isofun_h</a></dd>
				
				
			
				
				<dd><a href="#IsoFun">type IsoFun</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.CheckDerivs">func (o *IsoFun) CheckDerivs(A []float64, tol, tol2, tolq, tol3 float64, ver bool, args ...interface{}) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.DebugOutput">func (o *IsoFun) DebugOutput(princOnly bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Fa">func (o *IsoFun) Fa(A []float64, args ...interface{}) (res float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.FindIntersect">func (o *IsoFun) FindIntersect(p0, k float64, ΔL []float64, usek, debug bool, args ...interface{}) (L_at_int []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Fp">func (o *IsoFun) Fp(L []float64, args ...interface{}) (res float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Ga">func (o *IsoFun) Ga(dfdA, A []float64, args ...interface{}) (fval float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Get_bsmp">func (o *IsoFun) Get_bsmp() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Get_derivs_afterHa">func (o *IsoFun) Get_derivs_afterHa(dpdσ, dqdσ []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Get_pq">func (o *IsoFun) Get_pq() (p, q float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Gp">func (o *IsoFun) Gp(L []float64, args ...interface{}) (fval float64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.HafterGa">func (o *IsoFun) HafterGa(d2fdAdA [][]float64, args ...interface{}) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.HafterGp">func (o *IsoFun) HafterGp(args ...interface{}) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Init">func (o *IsoFun) Init(a, b, β, ϵ, shift float64, ncp int, ffcn Cb_isofun_f, gfcn Cb_isofun_g, hfcn Cb_isofun_h)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.PlotFfcn">func (o *IsoFun) PlotFfcn(dirout, fname string, pmin, pmax float64, np int, pq_point []float64, args_contour, args_point string, extra_before, extra_after func(), args ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.SetPrms">func (o *IsoFun) SetPrms(a, b, β, ϵ, shift float64, ffcn Cb_isofun_f, gfcn Cb_isofun_g, hfcn Cb_isofun_h)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.Set_bsmp">func (o *IsoFun) Set_bsmp(b float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IsoFun.String">func (o *IsoFun) String() (l string)</a></dd>
				
			
				
				<dd><a href="#NcteM">type NcteM</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.D2Mdw2">func (o *NcteM) D2Mdw2(w float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.DMdw">func (o *NcteM) DMdw(w float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.Deriv1">func (o *NcteM) Deriv1(dMdσ, σ, s []float64, p, q, w float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.Deriv2">func (o *NcteM) Deriv2(d2Mdσdσ [][]float64, dMdσ, σ, s []float64, p, q, w float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.Init">func (o *NcteM) Init(prms []string, vals []float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.M">func (o *NcteM) M(w float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NcteM.String">func (o *NcteM) String() (s string)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/cpmech/gosl/tsr/contmech.go">contmech.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/eigenprojs.go">eigenprojs.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/fcritcoef.go">fcritcoef.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/generalinvs.go">generalinvs.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/invariants.go">invariants.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/isofun.go">isofun.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/mandelops.go">mandelops.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/nonctem.go">nonctem.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/octahedral.go">octahedral.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/operators.go">operators.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/smpinvs.go">smpinvs.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/tensor.go">tensor.go</a>
			
				<a href="/src/github.com/cpmech/gosl/tsr/testing.go">testing.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls&mdash;perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
    <span id="EPS">EPS</span>         = 1e-16 <span class="comment">// smallest number satisfying 1.0 + EPS &gt; 1.0</span>
    <span id="QMIN">QMIN</span>        = 1e-10 <span class="comment">// smallest q value to compute qCam invariant</span>
    <span id="MINDET">MINDET</span>      = 1e-20 <span class="comment">// minimum determinant of tensor</span>
    <span id="GENINVSQEPS">GENINVSQEPS</span> = 1e-6  <span class="comment">// EPS tolerance to be added when computing q</span>
    <span id="SMPINVSTOL">SMPINVSTOL</span>  = 1e-8  <span class="comment">// tolerance used in SmpInvs to avoid sqrt(negativenumber)</span>
    <span id="SMPUSESRAMP">SMPUSESRAMP</span> = <a href="/pkg/builtin/#false">false</a> <span class="comment">// use smooth abs instead of smooth ramp</span>
    <span id="EV_ALPMIN">EV_ALPMIN</span>   = 1e-10 <span class="comment">// minimum α to be used in eigenprojectors derivatives</span>
    <span id="EV_ZERO">EV_ZERO</span>     = 1e-9  <span class="comment">// minimum eigenvalue</span>
    <span id="EV_EQUAL">EV_EQUAL</span>    = 1e-4  <span class="comment">// relative tolerance for equal eigenvalues</span>
)</pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span class="comment">// T2MI converts i-j-indices of 3x3 2nd order tensor to I-index in Mandel&#39;s representation</span>
    <span id="T2MI">T2MI</span> = [][]<a href="/pkg/builtin/#int">int</a>{
        {0, 3, 5},
        {3, 1, 4},
        {5, 4, 2},
    }

    <span class="comment">// TT2MI converts i-j-k-l-indices of 3x3x3x3 4th order tensor to I-index in Mandel&#39;s representation</span>
    <span id="TT2MI">TT2MI</span> = [][][][]<a href="/pkg/builtin/#int">int</a>{
        {{{0, 0, 0}, {0, 0, 0}, {0, 0, 0}}, {{3, 3, 3}, {3, 3, 3}, {3, 3, 3}}, {{5, 5, 5}, {5, 5, 5}, {5, 5, 5}}},
        {{{3, 3, 3}, {3, 3, 3}, {3, 3, 3}}, {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, {{4, 4, 4}, {4, 4, 4}, {4, 4, 4}}},
        {{{5, 5, 5}, {5, 5, 5}, {5, 5, 5}}, {{4, 4, 4}, {4, 4, 4}, {4, 4, 4}}, {{2, 2, 2}, {2, 2, 2}, {2, 2, 2}}},
    }

    <span class="comment">// TT2MJ converts i-j-k-l-indices of 3x3x3x3 4th order tensor to J-index in Mandel&#39;s representation</span>
    <span id="TT2MJ">TT2MJ</span> = [][][][]<a href="/pkg/builtin/#int">int</a>{
        {{{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}},
        {{{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}},
        {{{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}, {{0, 3, 5}, {3, 1, 4}, {5, 4, 2}}},
    }

    <span class="comment">// M2Ti converts I-index in Mandel&#39;s representation to i-index of 3x3 2nd order tensor</span>
    <span id="M2Ti">M2Ti</span> = []<a href="/pkg/builtin/#int">int</a>{0, 1, 2, 0, 1, 0}

    <span class="comment">// M2Tj converts I-index in Mandel&#39;s representation to j-index of 3x3 2nd order tensor</span>
    <span id="M2Tj">M2Tj</span> = []<a href="/pkg/builtin/#int">int</a>{0, 1, 2, 1, 2, 2}

    <span class="comment">// constants</span>
    <span id="SQ2">SQ2</span>    = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(2.0)       <span class="comment">// sqrt(2)</span>
    <span id="SQ3">SQ3</span>    = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(3.0)       <span class="comment">// sqrt(3)</span>
    <span id="SQ6">SQ6</span>    = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(6.0)       <span class="comment">// sqrt(6)</span>
    <span id="SQ3by2">SQ3by2</span> = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(3.0 / 2.0) <span class="comment">// sqrt(3/2)</span>
    <span id="SQ2by3">SQ2by3</span> = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(2.0 / 3.0) <span class="comment">// sqrt(2/3)</span>
    <span id="TWOSQ2">TWOSQ2</span> = 2.0 * <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Sqrt">Sqrt</a>(2.0) <span class="comment">// 2*sqrt(2) == 2^(3/2)</span>

    <span class="comment">// 3x3 2nd order identity tensor</span>
    <span id="It">It</span> = [][]<a href="/pkg/builtin/#float64">float64</a>{
        {1, 0, 0},
        {0, 1, 0},
        {0, 0, 1},
    }

    <span class="comment">// 3x3 2nd order identity tensor in Mandel&#39;s representation</span>
    <span id="Im">Im</span> = []<a href="/pkg/builtin/#float64">float64</a>{1, 1, 1, 0, 0, 0}

    <span class="comment">// 4th order identity tensor (symmetric) in Mandel&#39;s representation</span>
    <span id="IIm">IIm</span> = [][]<a href="/pkg/builtin/#float64">float64</a>{
        {1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
    }

    <span class="comment">// symmetric-deviatoric projector (3D) in Mandel&#39;s representation</span>
    <span class="comment">//Psd3dm = [][]float64{</span>
    <span id="Psd">Psd</span> = [][]<a href="/pkg/builtin/#float64">float64</a>{
        {2.0 / 3.0, -1.0 / 3.0, -1.0 / 3.0, 0.0, 0.0, 0.0},
        {-1.0 / 3.0, 2.0 / 3.0, -1.0 / 3.0, 0.0, 0.0, 0.0},
        {-1.0 / 3.0, -1.0 / 3.0, 2.0 / 3.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 1.0},
    }

    <span class="comment">// isotropic projector (3D) in Mandel&#39;s representation</span>
    <span class="comment">//Piso3dm = [][]float64{</span>
    <span id="Piso">Piso</span> = [][]<a href="/pkg/builtin/#float64">float64</a>{
        {1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 0.0, 0.0, 0.0},
        {1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 0.0, 0.0, 0.0},
        {1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    }
)</pre>
				
			
		
		
			
			
			<h2 id="Add">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/operators.go?s=1749:1826#L49">Add</a></h2>
			<pre>func Add(u [][]<a href="/pkg/builtin/#float64">float64</a>, α <a href="/pkg/builtin/#float64">float64</a>, a [][]<a href="/pkg/builtin/#float64">float64</a>, β <a href="/pkg/builtin/#float64">float64</a>, b [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Add adds two second order tensors according to:
</p>
<pre>u := α*a + β*b
</pre>

			
			

		
			
			
			<h2 id="Alloc2">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/tensor.go?s=3746:3780#L96">Alloc2</a></h2>
			<pre>func Alloc2() (tensor [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Alloc2 allocates a 3x3 2nd order tensor
</p>

			
			

		
			
			
			<h2 id="Alloc4">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/tensor.go?s=3934:3972#L105">Alloc4</a></h2>
			<pre>func Alloc4() (tensor [][][][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Alloc4 allocates a 3x3x3x3 4th order tensor
</p>

			
			

		
			
			
			<h2 id="AlmansiStrain">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=1160:1197#L41">AlmansiStrain</a></h2>
			<pre>func AlmansiStrain(e, Fi [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Eulerian or Almansi strain tensor: e := 0.5 * (I - inv(F)^t * inv(F))
Symmetric
</p>

			
			

		
			
			
			<h2 id="CauchyToPK1">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=1704:1757#L68">CauchyToPK1</a></h2>
			<pre>func CauchyToPK1(P, σ, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>, J <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Cauchy stress =&gt; first Piola-Kirchhoff: P := σ * inv(F)^t * J
</p>

			
			

		
			
			
			<h2 id="CauchyToPK2">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=2256:2309#L92">CauchyToPK2</a></h2>
			<pre>func CauchyToPK2(S, σ, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>, J <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Cauchy stress =&gt; second Piola-Kirchhoff: S := inv(F) * σ * inv(F)^t * J
</p>

			
			

		
			
			
			<h2 id="CheckEigenprojs">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/eigenprojs.go?s=7672:7756#L236">CheckEigenprojs</a></h2>
			<pre>func CheckEigenprojs(a []<a href="/pkg/builtin/#float64">float64</a>, tolP, tolS <a href="/pkg/builtin/#float64">float64</a>, ver <a href="/pkg/builtin/#bool">bool</a>) (λsorted []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
CheckEigenprojs checks eigen projectors
</p>

			
			

		
			
			
			<h2 id="CheckEigenprojsDerivs">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/eigenprojs.go?s=9948:10024#L320">CheckEigenprojsDerivs</a></h2>
			<pre>func CheckEigenprojsDerivs(a []<a href="/pkg/builtin/#float64">float64</a>, tol <a href="/pkg/builtin/#float64">float64</a>, ver <a href="/pkg/builtin/#bool">bool</a>, zero <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
CheckEigenprojsDerivs checks the derivatives of eigen projectors w.r.t defining tensor
</p>

			
			

		
			
			
			<h2 id="Det">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/operators.go?s=658:689#L20">Det</a></h2>
			<pre>func Det(a [][]<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Det computes the determinant of a second order tensor
</p>

			
			

		
			
			
			<h2 id="Dev">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/operators.go?s=397:439#L9">Dev</a></h2>
			<pre>func Dev(a [][]<a href="/pkg/builtin/#float64">float64</a>) (deva [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Dev returns the second order deviatoric tensor
</p>

			
			

		
			
			
			<h2 id="GenInvs">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/generalinvs.go?s=342:407#L6">GenInvs</a></h2>
			<pre>func GenInvs(L, n []<a href="/pkg/builtin/#float64">float64</a>, a <a href="/pkg/builtin/#float64">float64</a>) (p, q <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
GenInvs returns the SMP invariants
</p>
<pre>Note: L are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GenInvsDeriv1">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/generalinvs.go?s=1774:1885#L56">GenInvsDeriv1</a></h2>
			<pre>func GenInvsDeriv1(dpdL, dqdL []<a href="/pkg/builtin/#float64">float64</a>, L, n []<a href="/pkg/builtin/#float64">float64</a>, dndL [][]<a href="/pkg/builtin/#float64">float64</a>, a <a href="/pkg/builtin/#float64">float64</a>) (p, q <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
GenInvsDeriv1 computes the first order derivatives of p and q w.r.t L (shifted eigenvalues)
</p>
<pre>Note: L are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GenInvsDeriv2">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/generalinvs.go?s=2757:2899#L89">GenInvsDeriv2</a></h2>
			<pre>func GenInvsDeriv2(d2pdLdL, d2qdLdL [][]<a href="/pkg/builtin/#float64">float64</a>, L, n, dpdL, dqdL []<a href="/pkg/builtin/#float64">float64</a>, p, q <a href="/pkg/builtin/#float64">float64</a>, dndL [][]<a href="/pkg/builtin/#float64">float64</a>, d2ndLdL [][][]<a href="/pkg/builtin/#float64">float64</a>, a <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
GenInvsDeriv2 computes the second order derivatives of p and q w.r.t L (shifted eigenvalues)
</p>
<pre>Note: L are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GenTvec">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/generalinvs.go?s=912:943#L22">GenTvec</a></h2>
			<pre>func GenTvec(t, L, n []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
GenTvec computes the t vector (stress vector on SMP via Cauchy&#39;s rule: t = L dot n)
</p>
<pre>Note: L are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GenTvecDeriv1">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/generalinvs.go?s=1101:1171#L30">GenTvecDeriv1</a></h2>
			<pre>func GenTvecDeriv1(dtdL [][]<a href="/pkg/builtin/#float64">float64</a>, L, n []<a href="/pkg/builtin/#float64">float64</a>, dndL [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
GenTvecDeriv1 computes the first derivative dt/dL
</p>
<pre>Note: L are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GenTvecDeriv2">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/generalinvs.go?s=1421:1518#L43">GenTvecDeriv2</a></h2>
			<pre>func GenTvecDeriv2(i, j, k <a href="/pkg/builtin/#int">int</a>, L []<a href="/pkg/builtin/#float64">float64</a>, dndL [][]<a href="/pkg/builtin/#float64">float64</a>, d2ndLdL_ijk <a href="/pkg/builtin/#float64">float64</a>) (res <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
GenTvecDeriv2 computes the second derivative d²t/dLdL
</p>
<pre>Note: L are the eigenvalues (shifted or not)
</pre>

			
			

		
			
			
			<h2 id="GreenStrain">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=846:880#L25">GreenStrain</a></h2>
			<pre>func GreenStrain(E, F [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Lagrangian or Green strain tensor: E := 0.5 * (Ft * F - I)
Symmetric
</p>

			
			

		
			
			
			<h2 id="Inv">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/operators.go?s=903:955#L26">Inv</a></h2>
			<pre>func Inv(ai, a [][]<a href="/pkg/builtin/#float64">float64</a>) (det <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
Inv computes the inverse of a second order tensor
</p>
<pre>ai := Inv(a)
</pre>

			
			

		
			
			
			<h2 id="L2O">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/octahedral.go?s=396:451#L7">L2O</a></h2>
			<pre>func L2O(σ1, σ2, σ3 <a href="/pkg/builtin/#float64">float64</a>) (σa, σb, σc <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
L2O converts principal values (σ1,σ2,σ3) to octahedral values (σa,σb,σc)
</p>

			
			

		
			
			
			<h2 id="L_strains">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=1242:1289#L33">L_strains</a></h2>
			<pre>func L_strains(ε []<a href="/pkg/builtin/#float64">float64</a>) (εv, εd <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
L_strains compute strain invariants given principal values
</p>
<pre>ε -- principal values [3]
</pre>

			
			

		
			
			
			<h2 id="LeftCauchyGreenDef">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=581:622#L12">LeftCauchyGreenDef</a></h2>
			<pre>func LeftCauchyGreenDef(b, F [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Left Cauchy-Green deformation tensor: b := F * Ft
Symmetric and positive definite: det(b) = det(F)^2
</p>

			
			

		
			
			
			<h2 id="LinStrain">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=1459:1492#L56">LinStrain</a></h2>
			<pre>func LinStrain(ε, F [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Linear strain tensor: ε := 0.5 * (H + Ht) = 0.5 * (F + Ft) - I
</p>

			
			

		
			
			
			<h2 id="M2Phi">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/fcritcoef.go?s=1601:1642#L49">M2Phi</a></h2>
			<pre>func M2Phi(M <a href="/pkg/builtin/#float64">float64</a>, typ <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M2Phi calculates φ (friction angle at compression (degrees)) given M (max q/p at compression)
</p>

			
			

		
			
			
			<h2 id="M2T">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/tensor.go?s=4962:5018#L147">M2T</a></h2>
			<pre>func M2T(mandel []<a href="/pkg/builtin/#float64">float64</a>, i, j <a href="/pkg/builtin/#int">int</a>) (component <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M2T converts Mandel components to 3x3 second order tensor components,
i.e. correcting off-diagonal values that were multiplied by SQ2
</p>

			
			

		
			
			
			<h2 id="M2TT">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/tensor.go?s=5488:5541#L168">M2TT</a></h2>
			<pre>func M2TT(mandel [][]<a href="/pkg/builtin/#float64">float64</a>, i, j, k, l <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M2TT converts Mandel components to 3x3x3x3 fourth order tensor components,
i.e. correcting all values that were multiplied by 2 or SQ2
</p>

			
			

		
			
			
			<h2 id="M_Alloc2">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/tensor.go?s=4308:4345#L120">M_Alloc2</a></h2>
			<pre>func M_Alloc2(ndim <a href="/pkg/builtin/#int">int</a>) (a []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Alloc2 allocates a 2th order tensor in Mandel&#39;s representation (2*ndim)
</p>

			
			

		
			
			
			<h2 id="M_Alloc4">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/tensor.go?s=4490:4529#L127">M_Alloc4</a></h2>
			<pre>func M_Alloc4(ndim <a href="/pkg/builtin/#int">int</a>) (A [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Alloc4 allocates a 4th order tensor in Mandel&#39;s representation ((2*ndim)x(2*ndim))
</p>

			
			

		
			
			
			<h2 id="M_AllocEigenprojs">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/eigenprojs.go?s=1527:1574#L46">M_AllocEigenprojs</a></h2>
			<pre>func M_AllocEigenprojs(ncp <a href="/pkg/builtin/#int">int</a>) (P [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_AllocEigenprojs allocates new eigenprojectors P[3][ncp].
</p>
<pre>P[0] = {P0_0, P0_1, P0_2, P0_3, P0_4, P0_5}
P[1] = {P1_0, P1_1, P1_2, P1_3, P1_4, P1_5}
P[2] = {P2_0, P2_1, P2_2, P2_3, P2_4, P2_5}
</pre>

			
			

		
			
			
			<h2 id="M_CharInvs">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=7343:7392#L280">M_CharInvs</a></h2>
			<pre>func M_CharInvs(a []<a href="/pkg/builtin/#float64">float64</a>) (I1, I2, I3 <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_CharInvs computes the characteristic invariants of a 2nd order symmetric tensor
</p>

			
			

		
			
			
			<h2 id="M_CharInvsAndDerivs">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=7773:7862#L293">M_CharInvsAndDerivs</a></h2>
			<pre>func M_CharInvsAndDerivs(a []<a href="/pkg/builtin/#float64">float64</a>) (I1, I2, I3 <a href="/pkg/builtin/#float64">float64</a>, dI1da, dI2da, dI3da []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_CharInvsAndDerivs computes the characteristic invariants of a
2nd order symmetric and their derivatives
</p>

			
			

		
			
			
			<h2 id="M_Det">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=1059:1090#L27">M_Det</a></h2>
			<pre>func M_Det(a []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_Det calculates the determinant a 2nd order tensor represented in Mandel&#39;s basis
</p>
<pre>Note: this function also works for principal values with len(a) = 3
</pre>

			
			

		
			
			
			<h2 id="M_DetDeriv">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=1421:1452#L39">M_DetDeriv</a></h2>
			<pre>func M_DetDeriv(d, a []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_DetDeriv computes the derivative of the determinant of a w.r.t a
</p>
<pre>d := dDet(a)/da == dI3(a)/da
</pre>

			
			

		
			
			
			<h2 id="M_Dev">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=745:782#L17">M_Dev</a></h2>
			<pre>func M_Dev(a []<a href="/pkg/builtin/#float64">float64</a>) (s []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Dev calculates the deviator a 2nd order tensor represented in Mandel&#39;s basis
</p>

			
			

		
			
			
			<h2 id="M_Dot">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=4637:4707#L162">M_Dot</a></h2>
			<pre>func M_Dot(c []<a href="/pkg/builtin/#float64">float64</a>, a, b []<a href="/pkg/builtin/#float64">float64</a>, nonsymTol <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_Dot multiplies two second order symmetric tensors (the result may be non-symmetric)
An error is returned in case the result is non-symmetric
</p>
<pre>c = a dot b  =&gt;  cij = aik * bkj
</pre>

			
			

		
			
			
			<h2 id="M_Dy">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=3367:3408#L129">M_Dy</a></h2>
			<pre>func M_Dy(a, b []<a href="/pkg/builtin/#float64">float64</a>) (c [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Dy returns the dyadic product between a and b
</p>
<pre>c := a dy b
</pre>

			
			

		
			
			
			<h2 id="M_DyAdd">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=4288:4342#L150">M_DyAdd</a></h2>
			<pre>func M_DyAdd(c [][]<a href="/pkg/builtin/#float64">float64</a>, s <a href="/pkg/builtin/#float64">float64</a>, a, b []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_DyAdd adds the dyadic product between a and b scaled by s
</p>
<pre>c += s * a dy b
</pre>

			
			

		
			
			
			<h2 id="M_EigenProjsDerivAna">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/eigenprojs.go?s=2934:3023#L95">M_EigenProjsDerivAna</a></h2>
			<pre>func M_EigenProjsDerivAna(dPda [][][]<a href="/pkg/builtin/#float64">float64</a>, a, λ []<a href="/pkg/builtin/#float64">float64</a>, P [][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_EigenProjsDerivAna returns the derivatives of the eigenprojectors w.r.t its defining tensor
using the analytical formula.
</p>
<pre>Input:
  a -- (perturbed) tensor &#39;a&#39; (in Mandel basis)
  λ -- eigenvalues of &#39;a&#39;
  P -- eigenprojectors of &#39;a&#39;
Output:
  dPda -- the derivatives of P w.r.t &#39;a&#39;
</pre>

			
			

		
			
			
			<h2 id="M_EigenProjsDerivAuto">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/eigenprojs.go?s=6780:6870#L218">M_EigenProjsDerivAuto</a></h2>
			<pre>func M_EigenProjsDerivAuto(dPda [][][]<a href="/pkg/builtin/#float64">float64</a>, a, λ []<a href="/pkg/builtin/#float64">float64</a>, P [][]<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_EigenProjsDerivAuto computes the derivatives of the eigenprojectors of tensor a
w.r.t. to itself by automatically calling the numerical or the analytical formulae
depending on whether the eigenvalues are zero/repeated or not
</p>
<pre>Note: this function should work for non-perturbed tensors with zero/repeated eigenvalues.

Input:
  a -- tensor &#39;a&#39; (in Mandel basis)
  λ -- eigenvalues of &#39;a&#39;
  P -- eigenprojectors of &#39;a&#39;
Output:
  dPda -- the derivatives of P w.r.t &#39;a&#39;
</pre>

			
			

		
			
			
			<h2 id="M_EigenProjsDerivNum">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/eigenprojs.go?s=4847:4928#L143">M_EigenProjsDerivNum</a></h2>
			<pre>func M_EigenProjsDerivNum(dPda [][][]<a href="/pkg/builtin/#float64">float64</a>, a []<a href="/pkg/builtin/#float64">float64</a>, h <a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_EigenProjsDerivNum returns the derivatives of the eigenprojectors w.r.t its defining tensor
using the finite differences method.
</p>
<pre>Input:
  a -- tensor in Mandel basis
  h -- step size for finite differences
Output:
  dPda -- derivatives [3][ncp][ncp]
</pre>

			
			

		
			
			
			<h2 id="M_EigenValsNum">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/eigenprojs.go?s=896:944#L25">M_EigenValsNum</a></h2>
			<pre>func M_EigenValsNum(λ, a []<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_EigenValsNum returns the eigenvalues of tensor &#39;a&#39; (2nd order symmetric tensor in Mandel&#39;s basis)
using Jacobi rotation
</p>

			
			

		
			
			
			<h2 id="M_EigenValsProjsNum">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/eigenprojs.go?s=1830:1898#L56">M_EigenValsProjsNum</a></h2>
			<pre>func M_EigenValsProjsNum(P [][]<a href="/pkg/builtin/#float64">float64</a>, λ, a []<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_EigenValsProjsNum computes the eigenvalues and eigenprojectors of tensor &#39;a&#39; (2nd order symmetric tensor in Mandel&#39;s basis)
using Jacobi rotation.
</p>

			
			

		
			
			
			<h2 id="M_EigenValsVecsNum">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/eigenprojs.go?s=1180:1247#L35">M_EigenValsVecsNum</a></h2>
			<pre>func M_EigenValsVecsNum(Q [][]<a href="/pkg/builtin/#float64">float64</a>, λ, a []<a href="/pkg/builtin/#float64">float64</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_EigenValsVecs returns the eigenvalues and eigenvectors of tensor &#39;a&#39; (2nd order symmetric tensor in Mandel&#39;s basis)
using Jacobi rotation.
</p>

			
			

		
			
			
			<h2 id="M_Inv">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=6140:6205#L200">M_Inv</a></h2>
			<pre>func M_Inv(ai, a []<a href="/pkg/builtin/#float64">float64</a>, tol <a href="/pkg/builtin/#float64">float64</a>) (det <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_Inv computes the inverse of a 2nd order symmetric tensor &#39;a&#39;
</p>

			
			

		
			
			
			<h2 id="M_InvDeriv">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=7069:7113#L228">M_InvDeriv</a></h2>
			<pre>func M_InvDeriv(d [][]<a href="/pkg/builtin/#float64">float64</a>, ai []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_InvDeriv computes the derivative of the inverse of a tensor with respect to itself
</p>
<pre>ai := inv(a)
d  := dai/da
</pre>

			
			

		
			
			
			<h2 id="M_LodeDeriv1">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=4433:4491#L171">M_LodeDeriv1</a></h2>
			<pre>func M_LodeDeriv1(dwdσ, σ, s []<a href="/pkg/builtin/#float64">float64</a>, p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_LodeDeriv1 computes the first derivative of w w.r.t σ
</p>
<pre>Note: only dwdσ is output
</pre>

			
			

		
			
			
			<h2 id="M_LodeDeriv2">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=4932:5013#L189">M_LodeDeriv2</a></h2>
			<pre>func M_LodeDeriv2(d2wdσdσ [][]<a href="/pkg/builtin/#float64">float64</a>, dwdσ, σ, s []<a href="/pkg/builtin/#float64">float64</a>, p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_LodeDeriv2 computes the first and second derivatives of w w.r.t. σ
</p>
<pre>Note: d2wdσdσ and dwdσ output
</pre>

			
			

		
			
			
			<h2 id="M_Norm">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=308:340#L4">M_Norm</a></h2>
			<pre>func M_Norm(a []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_Norm calculates the norm of a 2nd order tensor represented in Mandel&#39;s basis
</p>

			
			

		
			
			
			<h2 id="M_PrincValsNum">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/eigenprojs.go?s=493:560#L9">M_PrincValsNum</a></h2>
			<pre>func M_PrincValsNum(a []<a href="/pkg/builtin/#float64">float64</a>) (λ0, λ1, λ2 <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_PrincValsNum returns the (sorted, ascending) eigenvalues of tensor &#39;a&#39; (2nd order symmetric tensor in Mandel&#39;s basis)
using Jacobi rotation.
</p>

			
			

		
			
			
			<h2 id="M_Sq">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=1738:1763#L51">M_Sq</a></h2>
			<pre>func M_Sq(b, a []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Sq returns the square of a tensor in Mandel&#39;s representation
</p>
<pre>b = a² = a single-dot a
</pre>

			
			

		
			
			
			<h2 id="M_SqDeriv">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=2346:2388#L69">M_SqDeriv</a></h2>
			<pre>func M_SqDeriv(d [][]<a href="/pkg/builtin/#float64">float64</a>, a []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_SqDeriv (Mandel) derivative of square of a tensor
</p>
<pre>d = derivative of a² w.r.t a
</pre>

			
			

		
			
			
			<h2 id="M_Tr">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/mandelops.go?s=600:630#L12">M_Tr</a></h2>
			<pre>func M_Tr(a []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_Tr calculates the trace a 2nd order tensor represented in Mandel&#39;s basis
</p>

			
			

		
			
			
			<h2 id="M_Ts">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=5792:5830#L221">M_Ts</a></h2>
			<pre>func M_Ts(Ts [][]<a href="/pkg/builtin/#float64">float64</a>, s []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_Ts computes Ts = Psd:(ds²/ds):Psd
</p>

			
			

		
			
			
			<h2 id="M_devε">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=2052:2105#L54">M_devε</a></h2>
			<pre>func M_devε(e, ε []<a href="/pkg/builtin/#float64">float64</a>) (eno, εv, εd <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_devε returns the deviator of ε (e := dev(ε)), the norm of the deviator (eno) and the εv, εd invariants
</p>
<pre>Note: this function also works for principal values with len(ε) = len(e) = 3
</pre>

			
			

		
			
			
			<h2 id="M_devσ">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=1637:1686#L41">M_devσ</a></h2>
			<pre>func M_devσ(s, σ []<a href="/pkg/builtin/#float64">float64</a>) (sno, p, q <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_devσ returns the deviator of σ (s := dev(σ)), the norm of the deviator (sno) and the p, q invariants
</p>
<pre>Note: this function also works for principal values with len(σ) = len(s) = 3
</pre>

			
			

		
			
			
			<h2 id="M_oct">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/octahedral.go?s=1553:1600#L45">M_oct</a></h2>
			<pre>func M_oct(a []<a href="/pkg/builtin/#float64">float64</a>) (σa, σb, σc <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_oct computes octahedral values of a 2nd order symmetric tensor with Mandel components
</p>
<pre>Note: the (p,q,w) stress invariants are firstly computed;
      thus, it is more efficient to compute (p,q,w) first and then use &#39;PQW2O&#39;
</pre>

			
			

		
			
			
			<h2 id="M_p">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=388:418#L4">M_p</a></h2>
			<pre>func M_p(σ []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_p returns the hydrostatic pressure == negative of the mean pressure == - tr(σ) / 3
</p>

			
			

		
			
			
			<h2 id="M_pq_smp">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=8640:8715#L318">M_pq_smp</a></h2>
			<pre>func M_pq_smp(σ []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (p, q <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
M_pq_smp computes p and q SMP invariants of 2nd order symmetric tensor (Mandel components)
</p>
<pre>Note: 1) σ is a 2D or 3D symmetric tensor (len(σ)==4 or 6)
      2) this function creates a number of local arrays =&gt; not efficient
</pre>

			
			

		
			
			
			<h2 id="M_pqw">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=2916:2957#L94">M_pqw</a></h2>
			<pre>func M_pqw(a []<a href="/pkg/builtin/#float64">float64</a>) (p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_pqw returns p, q and w invariants
</p>

			
			

		
			
			
			<h2 id="M_pqws">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=3966:4011#L146">M_pqws</a></h2>
			<pre>func M_pqws(s, a []<a href="/pkg/builtin/#float64">float64</a>) (p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_pqws returns p, q, w invariants and the deviatoric stress s := dev(σ)
</p>
<pre>Note: this function also works for principal values with len(a) = len(s) = 3
</pre>

			
			

		
			
			
			<h2 id="M_pqθ">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=3359:3402#L119">M_pqθ</a></h2>
			<pre>func M_pqθ(a []<a href="/pkg/builtin/#float64">float64</a>) (p, q, θ <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_pqθ returns p, q and θ invariants
</p>

			
			

		
			
			
			<h2 id="M_q">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=507:537#L9">M_q</a></h2>
			<pre>func M_q(σ []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_q returns von Mises&#39; equivalent stress
</p>

			
			

		
			
			
			<h2 id="M_w">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=2338:2371#L66">M_w</a></h2>
			<pre>func M_w(a []<a href="/pkg/builtin/#float64">float64</a>) (w <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_w returns the Lode invariant -1 ≤ w := sin(3θ) ≤ 1
</p>

			
			

		
			
			
			<h2 id="M_εd">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=901:933#L23">M_εd</a></h2>
			<pre>func M_εd(ε []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_εd returns the deviatoric strain
</p>

			
			

		
			
			
			<h2 id="M_εv">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=794:826#L18">M_εv</a></h2>
			<pre>func M_εv(ε []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
M_εv returns the volumetric strain
</p>

			
			

		
			
			
			<h2 id="M_θ">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/invariants.go?s=2781:2819#L89">M_θ</a></h2>
			<pre>func M_θ(a []<a href="/pkg/builtin/#float64">float64</a>) (θdeg <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
M_θ returns the Lode invariant -30° ≤ θ := asin(w) / 3 ≤ 30°
</p>

			
			

		
			
			
			<h2 id="Man2Ten">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/tensor.go?s=5821:5871#L180">Man2Ten</a></h2>
			<pre>func Man2Ten(tensor [][]<a href="/pkg/builtin/#float64">float64</a>, mandel []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Man2Ten returns the 3x3 2nd order tensor from its Mandel representation
</p>

			
			

		
			
			
			<h2 id="Mmatch">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/fcritcoef.go?s=575:631#L9">Mmatch</a></h2>
			<pre>func Mmatch(c, φ <a href="/pkg/builtin/#float64">float64</a>, cone <a href="/pkg/builtin/#string">string</a>) (M, qy0 <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Mmatch computes M=q/p and qy0 from c and φ corresponding to the strength that would
be modelled by the Mohr-Coulomb model matching one of the following cones:
</p>
<pre>cone == &#34;cmp&#34; : compression cone (outer)
     == &#34;ext&#34; : extension cone (inner)
     == &#34;psa&#34; : plane-strain
Note: p, q, and M are Cambridge (conventional) quantities
</pre>

			
			

		
			
			
			<h2 id="O2L">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/octahedral.go?s=639:694#L15">O2L</a></h2>
			<pre>func O2L(σa, σb, σc <a href="/pkg/builtin/#float64">float64</a>) (σ1, σ2, σ3 <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
O2L converts octahedral values (σa,σb,σc) to principal values (σ1,σ2,σ3)
</p>

			
			

		
			
			
			<h2 id="O2Lmat">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/octahedral.go?s=890:919#L23">O2Lmat</a></h2>
			<pre>func O2Lmat() (L [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
O2Lmat computes L[I:{1,2,3}][A:{a,b,c}] = dσI/dσA =&gt; σI = L * σA
</p>

			
			

		
			
			
			<h2 id="PK1ToCauchy">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=1972:2025#L80">PK1ToCauchy</a></h2>
			<pre>func PK1ToCauchy(σ, P, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>, J <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
First Piola-Kirchhoff =&gt; Cauchy stress: σ := P * Ft / J
</p>

			
			

		
			
			
			<h2 id="PK2ToCauchy">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=2576:2629#L106">PK2ToCauchy</a></h2>
			<pre>func PK2ToCauchy(σ, S, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>, J <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Second Piola-Kirchhoff =&gt; Cauchy stress: σ := F * S * Ft / J
</p>

			
			

		
			
			
			<h2 id="PQW2O">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/octahedral.go?s=1118:1169#L32">PQW2O</a></h2>
			<pre>func PQW2O(p, q, w <a href="/pkg/builtin/#float64">float64</a>) (σa, σb, σc <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
PQW2O converts p,q,w to octahedral values (σa,σb,σc)
</p>

			
			

		
			
			
			<h2 id="Phi2M">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/fcritcoef.go?s=1238:1280#L35">Phi2M</a></h2>
			<pre>func Phi2M(φ <a href="/pkg/builtin/#float64">float64</a>, typ <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Phi2M calculates M = max q/p at compression (φ: friction angle at compression (degrees)).
type = {&#34;oct&#34;, &#34;cam&#34;, &#34;smp&#34;}
</p>

			
			

		
			
			
			<h2 id="PlotOct">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/octahedral.go?s=4721:4920#L121">PlotOct</a></h2>
			<pre>func PlotOct(filename <a href="/pkg/builtin/#string">string</a>, σcCte, rmin, rmax <a href="/pkg/builtin/#float64">float64</a>, nr, nα <a href="/pkg/builtin/#int">int</a>, φ <a href="/pkg/builtin/#float64">float64</a>, F <a href="#Cb_F_t">Cb_F_t</a>, G <a href="#Cb_G_t">Cb_G_t</a>,
    notpolarc, simplec, only0, grads, showpts, first, last <a href="/pkg/builtin/#bool">bool</a>, ferr <a href="/pkg/builtin/#float64">float64</a>, args ...interface{})</pre>
			<p>
PlotOct plots a function cross-section and gradients projections on octahedral plane
</p>

			
			

		
			
			
			<h2 id="PlotRefOct">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/octahedral.go?s=3876:3928#L97">PlotRefOct</a></h2>
			<pre>func PlotRefOct(φ, σc <a href="/pkg/builtin/#float64">float64</a>, withExtCircle <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
PlotRefOct plots reference failure criterions in octahedral plane:
</p>
<pre>Drucker-Prager and Mohr-Circles
</pre>

			
			

		
			
			
			<h2 id="PlotRosette">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/octahedral.go?s=1716:1787#L52">PlotRosette</a></h2>
			<pre>func PlotRosette(r <a href="/pkg/builtin/#float64">float64</a>, full, ref <a href="/pkg/builtin/#bool">bool</a>, withtext <a href="/pkg/builtin/#bool">bool</a>, fsz <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
PlotRosette plots rosette in octahedral plane
</p>

			
			

		
			
			
			<h2 id="PullBack">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=3211:3251#L134">PullBack</a></h2>
			<pre>func PullBack(res, a, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Pull-back (type A/cov): res := push-back(a) = Ft * a * F
</p>

			
			

		
			
			
			<h2 id="PullBackB">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=3836:3877#L162">PullBackB</a></h2>
			<pre>func PullBackB(res, a, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Pull-back (type B/contra): res := pull-back(a) = inv(F) * a * inv(F)^t
</p>

			
			

		
			
			
			<h2 id="PushForward">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=2907:2950#L120">PushForward</a></h2>
			<pre>func PushForward(res, a, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Push-forward (type A/cov): res := push-forward(a) = inv(F)^t * a * inv(F)
</p>

			
			

		
			
			
			<h2 id="PushForwardB">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=3519:3563#L148">PushForwardB</a></h2>
			<pre>func PushForwardB(res, a, F, Fi [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Push-forward (type B/contra): res := push-forward(a) = F * a * Ft
</p>

			
			

		
			
			
			<h2 id="RightCauchyGreenDef">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/contmech.go?s=283:325#L1">RightCauchyGreenDef</a></h2>
			<pre>func RightCauchyGreenDef(C, F [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Right Cauchy-Green deformation tensor: C := Ft * F
Symmetric and positive definite: det(C) = det(F)^2
</p>

			
			

		
			
			
			<h2 id="SMPderivs1">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/generalinvs.go?s=4170:4258#L128">SMPderivs1</a></h2>
			<pre>func SMPderivs1(dpdL, dqdL, L []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (p, q <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
SMPderivs1 computes the 1st order derivatives of SMP invariants
</p>
<pre>Note: internal variables are created =&gt; not efficient
</pre>

			
			

		
			
			
			<h2 id="SMPinvs">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/generalinvs.go?s=3764:3837#L118">SMPinvs</a></h2>
			<pre>func SMPinvs(L []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (p, q <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
SMPinvs computes the SMP invariants, after the internal computation of the SMP unit director
</p>
<pre>Note: internal variables are created =&gt; not efficient
</pre>

			
			

		
			
			
			<h2 id="SmpCalcμ">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/smpinvs.go?s=303:356#L4">SmpCalcμ</a></h2>
			<pre>func SmpCalcμ(φ, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (μ <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpCalcμ computes μ=q/p to satisfy Mohr-Coulomb criterion @ compression
</p>

			
			

		
			
			
			<h2 id="SmpDerivs1">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/smpinvs.go?s=5118:5223#L137">SmpDerivs1</a></h2>
			<pre>func SmpDerivs1(dndL [][]<a href="/pkg/builtin/#float64">float64</a>, dNdL, N, F, G []<a href="/pkg/builtin/#float64">float64</a>, L []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (m <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpDerivs1 computes the first derivative and other variables
</p>
<pre>Note: m, dNdL, N, F and G are output
</pre>

			
			

		
			
			
			<h2 id="SmpDerivs2">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/smpinvs.go?s=6245:6364#L176">SmpDerivs2</a></h2>
			<pre>func SmpDerivs2(d2ndLdL [][][]<a href="/pkg/builtin/#float64">float64</a>, L []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ, m <a href="/pkg/builtin/#float64">float64</a>, N, F, G, dNdL []<a href="/pkg/builtin/#float64">float64</a>, dndL [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpDerivs2 computes the second order derivative
</p>
<pre>Note: m, N, F, G, dNdL and dndL are input
</pre>

			
			

		
			
			
			<h2 id="SmpDirector">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/smpinvs.go?s=933:999#L22">SmpDirector</a></h2>
			<pre>func SmpDirector(N, L []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>) (m <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpDirector computes the director (normal vector) of the spatially mobilised plane
</p>
<pre>Notes:
  1) the norm of N is returned =&gt; m := norm(N)
  2) if !SMPUSESRAMP, β==eps and must be a small quantity
</pre>

			
			

		
			
			
			<h2 id="SmpDirectorDeriv1">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/smpinvs.go?s=1566:1639#L39">SmpDirectorDeriv1</a></h2>
			<pre>func SmpDirectorDeriv1(dNdL []<a href="/pkg/builtin/#float64">float64</a>, L []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpDirectorDeriv1 computes the first order derivative of the SMP director
</p>
<pre>Notes: Only non-zero components are returned; i.e. dNdL[i] := dNdL[i][i]
</pre>

			
			

		
			
			
			<h2 id="SmpDirectorDeriv2">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/smpinvs.go?s=2375:2450#L54">SmpDirectorDeriv2</a></h2>
			<pre>func SmpDirectorDeriv2(d2NdL2 []<a href="/pkg/builtin/#float64">float64</a>, L []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpDirectorDeriv2 computes the second order derivative of the SMP director
</p>
<pre>Notes: Only the non-zero components are returned; i.e.: d²NdL2[i] := d²N[i]/dL[i]dL[i]
</pre>

			
			

		
			
			
			<h2 id="SmpNormDirectorDeriv1">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/smpinvs.go?s=3060:3132#L75">SmpNormDirectorDeriv1</a></h2>
			<pre>func SmpNormDirectorDeriv1(dmdL []<a href="/pkg/builtin/#float64">float64</a>, m <a href="/pkg/builtin/#float64">float64</a>, N, dNdL []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpNormDirectorDeriv1 computes the first derivative of the norm of the SMP director
</p>
<pre>Note: m, N and dNdL are input
</pre>

			
			

		
			
			
			<h2 id="SmpNormDirectorDeriv2">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/smpinvs.go?s=3370:3488#L83">SmpNormDirectorDeriv2</a></h2>
			<pre>func SmpNormDirectorDeriv2(d2mdLdL [][]<a href="/pkg/builtin/#float64">float64</a>, L []<a href="/pkg/builtin/#float64">float64</a>, a, b, β, ϵ, m <a href="/pkg/builtin/#float64">float64</a>, N, dNdL, d2NdL2, dmdL []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpNormDirectorDeriv2 computes the second order derivative of the norm of the SMP director
</p>
<pre>Note: m, N, dNdL, d2NdL2 and dmdL are input
</pre>

			
			

		
			
			
			<h2 id="SmpUnitDirector">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/smpinvs.go?s=3875:3932#L98">SmpUnitDirector</a></h2>
			<pre>func SmpUnitDirector(n []<a href="/pkg/builtin/#float64">float64</a>, m <a href="/pkg/builtin/#float64">float64</a>, N []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpUnitDirector computed the unit normal of the SMP
</p>
<pre>Note: m and N are input
</pre>

			
			

		
			
			
			<h2 id="SmpUnitDirectorDeriv1">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/smpinvs.go?s=4107:4187#L106">SmpUnitDirectorDeriv1</a></h2>
			<pre>func SmpUnitDirectorDeriv1(dndL [][]<a href="/pkg/builtin/#float64">float64</a>, m <a href="/pkg/builtin/#float64">float64</a>, N, dNdL, dmdL []<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpUnitDirectorDeriv1 computes the first derivative of the SMP unit normal
</p>
<pre>Note: m, N, dNdL and dmdL are input
</pre>

			
			

		
			
			
			<h2 id="SmpUnitDirectorDeriv2">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/smpinvs.go?s=4527:4650#L120">SmpUnitDirectorDeriv2</a></h2>
			<pre>func SmpUnitDirectorDeriv2(d2ndLdL [][][]<a href="/pkg/builtin/#float64">float64</a>, m <a href="/pkg/builtin/#float64">float64</a>, N, dNdL, d2NdL2, dmdL, n []<a href="/pkg/builtin/#float64">float64</a>, d2mdLdL, dndL [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
SmpUnitDirectorDeriv2 computes the second order derivative of the unit director of the SMP
d²n[i]/dL[j]dL[k]
</p>
<pre>Note: m, N, dNdL, d2NdL2, dmdL, n, d2mdLdL and dndL are input
</pre>

			
			

		
			
			
			<h2 id="Ten2Man">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/tensor.go?s=6531:6581#L196">Ten2Man</a></h2>
			<pre>func Ten2Man(mandel []<a href="/pkg/builtin/#float64">float64</a>, tensor [][]<a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Ten2Man returns the Mandel representation of a 3x3 2nd order tensor
</p>

			
			

		
			
			
			<h2 id="Tr">func <a href="https://github.com/cpmech/gosl/blob/master/tsr/operators.go?s=275:305#L4">Tr</a></h2>
			<pre>func Tr(a [][]<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Tr returns the trace of a second order tensor
</p>

			
			

		
		
			
			
			<h2 id="Cb_F_t">type <a href="https://github.com/cpmech/gosl/blob/master/tsr/octahedral.go?s=4472:4548#L117">Cb_F_t</a></h2>
			<pre>type Cb_F_t func(A []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (fval <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="Cb_G_t">type <a href="https://github.com/cpmech/gosl/blob/master/tsr/octahedral.go?s=4549:4631#L118">Cb_G_t</a></h2>
			<pre>type Cb_G_t func(dfdA, A []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (fval <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="Cb_isofun_f">type <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=378:442#L7">Cb_isofun_f</a></h2>
			<pre>type Cb_isofun_f func(p, q <a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Callbacks
</p>


			

			

			
			
			

			

			
		
			
			
			<h2 id="Cb_isofun_g">type <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=443:520#L8">Cb_isofun_g</a></h2>
			<pre>type Cb_isofun_g func(p, q <a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (dfdp, dfdq <a href="/pkg/builtin/#float64">float64</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="Cb_isofun_h">type <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=521:611#L9">Cb_isofun_h</a></h2>
			<pre>type Cb_isofun_h func(p, q <a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (d2fdp2, d2fdq2, d2fdpdq <a href="/pkg/builtin/#float64">float64</a>)</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="IsoFun">type <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=673:2016#L12">IsoFun</a></h2>
			<pre>type IsoFun struct {

    <span class="comment">// eigenvalues/projectors</span>
    L, Ls []<a href="/pkg/builtin/#float64">float64</a>   <span class="comment">// eigenvalues and shifted eigenvalues</span>
    P     [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// eigenprojectors</span>

    N          []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// SMP director and unit director</span>
    Frmp, Grmp []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// ramp function values</span>

    DfdL []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// first derivative of f</span>

    <span class="comment">// for second derivatives</span>
    Acpy []<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// copy of tensor &#39;A&#39;</span>

    DgdL [][]<a href="/pkg/builtin/#float64">float64</a> <span class="comment">// second derivative of f</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
IsoFun handles isotropic functions and their derivatives
</p>


			

			

			
			
			

			

			
				
				<h3 id="IsoFun.CheckDerivs">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/testing.go?s=369:484#L5">CheckDerivs</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) CheckDerivs(A []<a href="/pkg/builtin/#float64">float64</a>, tol, tol2, tolq, tol3 <a href="/pkg/builtin/#float64">float64</a>, ver <a href="/pkg/builtin/#bool">bool</a>, args ...interface{}) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
CheckDerivs check derivatives computed by isotropic function
</p>

				
				
				
			
				
				<h3 id="IsoFun.DebugOutput">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=14757:14801#L546">DebugOutput</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) DebugOutput(princOnly <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
DebugOutput outputs debug information
</p>

				
				
				
			
				
				<h3 id="IsoFun.Fa">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=5975:6053#L184">Fa</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Fa(A []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Fa evaluates the isotropic function @ A (a second order tensor in Mandel&#39;s basis)
</p>

				
				
				
			
				
				<h3 id="IsoFun.FindIntersect">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=9713:9833#L317">FindIntersect</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) FindIntersect(p0, k <a href="/pkg/builtin/#float64">float64</a>, ΔL []<a href="/pkg/builtin/#float64">float64</a>, usek, debug <a href="/pkg/builtin/#bool">bool</a>, args ...interface{}) (L_at_int []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
FindIntersect find point on surface using Newton&#39;s method
</p>

				
				
				
			
				
				<h3 id="IsoFun.Fp">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=3652:3730#L102">Fp</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Fp(L []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (res <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Fp evaluates the isotropic function @ L (principal values)
</p>

				
				
				
			
				
				<h3 id="IsoFun.Ga">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=6444:6529#L202">Ga</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Ga(dfdA, A []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (fval <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Ga computes f and dfdA @ A (a second order tensor in Mandel&#39;s basis)
</p>
<pre>Notes:
 1) eigenvalues are stored in L and eigenprojectors are stored in P
 2) DfdL is calculated and is availabe for external use
</pre>

				
				
				
			
				
				<h3 id="IsoFun.Get_bsmp">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=2031:2066#L54">Get_bsmp</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Get_bsmp() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Accessors
</p>

				
				
				
			
				
				<h3 id="IsoFun.Get_derivs_afterHa">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=8332:8391#L276">Get_derivs_afterHa</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Get_derivs_afterHa(dpdσ, dqdσ []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Get_derivs_afterHa returns the derivatives of SMP invariants after a call to HafterGa
</p>

				
				
				
			
				
				<h3 id="IsoFun.Get_pq">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=2140:2180#L56">Get_pq</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Get_pq() (p, q <a href="/pkg/builtin/#float64">float64</a>)</pre>
				
				
				
				
			
				
				<h3 id="IsoFun.Gp">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=4218:4297#L126">Gp</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Gp(L []<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (fval <a href="/pkg/builtin/#float64">float64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
Gp computes f and DfdL @ L (principal values)
Notes:
</p>
<pre>1) L is input =&gt; shifted and copied into to internal Ls for use in Hp
2) output is stored in DfdL
</pre>

				
				
				
			
				
				<h3 id="IsoFun.HafterGa">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=7147:7226#L236">HafterGa</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) HafterGa(d2fdAdA [][]<a href="/pkg/builtin/#float64">float64</a>, args ...interface{}) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
HafterGa computes d2fdada after G is called
</p>
<pre>Input:
  dfdA -- df/da
  args -- extra arguments
Output:
  d2fdAdA -- d²f/dAdA
Notes:
  1) DgdL==d2fdLdL is calculated and is availabe for external use
</pre>

				
				
				
			
				
				<h3 id="IsoFun.HafterGp">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=5065:5123#L157">HafterGp</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) HafterGp(args ...interface{}) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>
HafterGp computes d2fdLdL == dgdL after Gp was called
Notes:
</p>
<pre>1) output is stored in DgdL
</pre>

				
				
				
			
				
				<h3 id="IsoFun.Init">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=2546:2659#L66">Init</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Init(a, b, β, ϵ, shift <a href="/pkg/builtin/#float64">float64</a>, ncp <a href="/pkg/builtin/#int">int</a>, ffcn <a href="#Cb_isofun_f">Cb_isofun_f</a>, gfcn <a href="#Cb_isofun_g">Cb_isofun_g</a>, hfcn <a href="#Cb_isofun_h">Cb_isofun_h</a>)</pre>
				<p>
Init initialises the isotropic function structure
</p>

				
				
				
			
				
				<h3 id="IsoFun.PlotFfcn">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=8933:9116#L293">PlotFfcn</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) PlotFfcn(dirout, fname <a href="/pkg/builtin/#string">string</a>, pmin, pmax <a href="/pkg/builtin/#float64">float64</a>, np <a href="/pkg/builtin/#int">int</a>, pq_point []<a href="/pkg/builtin/#float64">float64</a>, args_contour, args_point <a href="/pkg/builtin/#string">string</a>, extra_before, extra_after func(), args ...interface{})</pre>
				<p>
Plots Ffcn
</p>

				
				
				
			
				
				<h3 id="IsoFun.SetPrms">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=2228:2335#L59">SetPrms</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) SetPrms(a, b, β, ϵ, shift <a href="/pkg/builtin/#float64">float64</a>, ffcn <a href="#Cb_isofun_f">Cb_isofun_f</a>, gfcn <a href="#Cb_isofun_g">Cb_isofun_g</a>, hfcn <a href="#Cb_isofun_h">Cb_isofun_h</a>)</pre>
				<p>
SetPrms set parameters
</p>

				
				
				
			
				
				<h3 id="IsoFun.Set_bsmp">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=2087:2123#L55">Set_bsmp</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) Set_bsmp(b <a href="/pkg/builtin/#float64">float64</a>)</pre>
				
				
				
				
			
				
				<h3 id="IsoFun.String">func (*IsoFun) <a href="https://github.com/cpmech/gosl/blob/master/tsr/isofun.go?s=14604:14640#L540">String</a></h3>
				<pre>func (o *<a href="#IsoFun">IsoFun</a>) String() (l <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
String returns information of this object
</p>

				
				
				
			
		
			
			
			<h2 id="NcteM">type <a href="https://github.com/cpmech/gosl/blob/master/tsr/nonctem.go?s=327:455#L5">NcteM</a></h2>
			<pre>type NcteM struct {
    Mfix <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// derived</span>
    Sinφ <a href="/pkg/builtin/#float64">float64</a>
    Tanφ <a href="/pkg/builtin/#float64">float64</a>
    Mcs  <a href="/pkg/builtin/#float64">float64</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
NcteM implements Argyris-Sheng et al M(w) non-constant M coefficient
</p>


			

			

			
			
			

			

			
				
				<h3 id="NcteM.D2Mdw2">func (*NcteM) <a href="https://github.com/cpmech/gosl/blob/master/tsr/nonctem.go?s=1483:1524#L58">D2Mdw2</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) D2Mdw2(w <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
D2Mdw2 implements d²M/dw²
</p>

				
				
				
			
				
				<h3 id="NcteM.DMdw">func (*NcteM) <a href="https://github.com/cpmech/gosl/blob/master/tsr/nonctem.go?s=1307:1346#L50">DMdw</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) DMdw(w <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
DMdw implements dM/dw
</p>

				
				
				
			
				
				<h3 id="NcteM.Deriv1">func (*NcteM) <a href="https://github.com/cpmech/gosl/blob/master/tsr/nonctem.go?s=1753:1816#L68">Deriv1</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) Deriv1(dMdσ, σ, s []<a href="/pkg/builtin/#float64">float64</a>, p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Deriv1 returns the first derivative of M w.r.t σ
</p>
<pre>Note: only dMdσ is output
</pre>

				
				
				
			
				
				<h3 id="NcteM.Deriv2">func (*NcteM) <a href="https://github.com/cpmech/gosl/blob/master/tsr/nonctem.go?s=2130:2216#L84">Deriv2</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) Deriv2(d2Mdσdσ [][]<a href="/pkg/builtin/#float64">float64</a>, dMdσ, σ, s []<a href="/pkg/builtin/#float64">float64</a>, p, q, w <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Deriv2 returns the first and second derivatives of M w.r.t σ
</p>
<pre>Note: d2Mdσdσ and dMdσ output
</pre>

				
				
				
			
				
				<h3 id="NcteM.Init">func (*NcteM) <a href="https://github.com/cpmech/gosl/blob/master/tsr/nonctem.go?s=489:540#L17">Init</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) Init(prms []<a href="/pkg/builtin/#string">string</a>, vals []<a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Init initialises this object
</p>

				
				
				
			
				
				<h3 id="NcteM.M">func (*NcteM) <a href="https://github.com/cpmech/gosl/blob/master/tsr/nonctem.go?s=1138:1174#L42">M</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) M(w <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
M implements M(w)
</p>

				
				
				
			
				
				<h3 id="NcteM.String">func (*NcteM) <a href="https://github.com/cpmech/gosl/blob/master/tsr/nonctem.go?s=1013:1048#L37">String</a></h3>
				<pre>func (o *<a href="#NcteM">NcteM</a>) String() (s <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
String returns a string representing this structure
</p>

				
				
				
			
		
	

	






<div id="footer">
<br /><br />
<hr>
<pre class="copyright">
Copyright (c) 2016, The Gosl Authors. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of Gosl nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

</pre><!-- copyright -->
</div><!-- footer -->

</div><!-- container -->
</div><!-- page -->
</body>
</html>
