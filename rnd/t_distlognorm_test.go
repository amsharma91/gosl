// Copyright 2012 Dorival de Moraes Pedroso. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rnd

import (
	"testing"

	"github.com/cpmech/gosl/chk"
	"github.com/cpmech/gosl/io"
	"github.com/cpmech/gosl/plt"
	"github.com/cpmech/gosl/utl"
)

func plot_lognormal(μ, σ float64) {

	var lognrm LogNormal
	lognrm.Init(μ, σ)
	//io.Pforan("lognrm = %+v\n", lognrm)

	n := 101
	x := utl.LinSpace(0, 3, n)
	y := make([]float64, n)
	Y := make([]float64, n)
	for i := 0; i < n; i++ {
		y[i] = lognrm.Pdf(x[i])
		Y[i] = lognrm.Cdf(x[i])
	}
	plt.Subplot(2, 1, 1)
	plt.Plot(x, y, io.Sf("label='$\\mu=%g,\\;\\sigma=%g$'", μ, σ))
	plt.Subplot(2, 1, 2)
	plt.Plot(x, Y, io.Sf("label='$\\mu=%g,\\; \\sigma=%g$'", μ, σ))
}

func Test_lognorm01(tst *testing.T) {

	//verbose()
	chk.PrintTitle("lognorm01")

	plt.SetForEps(1.5, 300)

	for _, σ := range []float64{1, 0.5, 0.25} {
		plot_lognormal(0, σ)
	}

	// values from R language: dnorm and pnorm functions. Example:
	//  options(digits=17)
	//  X = seq(0, 3, 0.25)
	//  dnorm(X, 0, 0.25)
	X := []float64{0.00, 0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75, 2.00, 2.25, 2.50, 2.75, 3.00}
	pdf_μ0_σ025 := []float64{0.0000000000000000e+00, 1.3426755490116912e-06, 6.8349495096432164e-02, 1.0974069753632885e+00, 1.5957691216057308e+00, 8.5715880056255800e-01, 2.8555377571925905e-01, 7.4450664020965812e-02, 1.7087373774108041e-02, 3.6814929619841388e-03, 7.7268078822629541e-04, 1.6151115930367854e-04, 3.4078354273924143e-05}
	pdf_μ0_σ05 := []float64{0.000000000000000000, 0.068349495096432164, 0.610455304190183234, 0.901557703729439885, 0.797884560802865406, 0.577803754559389593, 0.382869771988592789, 0.243717185734742298, 0.152613826047545809, 0.095184591906419674, 0.059530916570285738, 0.037475605662833117, 0.023794482261436555}
	pdf_μ0_σ1 := []float64{0.000000000000000000, 0.610455304190183234, 0.627496077115924367, 0.510361006313849286, 0.398942280401432703, 0.311306099911394241, 0.244973651710509915, 0.194925228762766523, 0.156874019278981092, 0.127623257329530948, 0.104871066889649839, 0.086968643299711032, 0.072728256139994715}
	pdf_μ1_σ025 := []float64{0.0000000000000000e+00, 1.0487098900878497e-19, 3.4986421571134842e-10, 3.6897086585820309e-06, 5.3532090305954147e-04, 1.0215641444463604e-02, 6.2920504569106833e-02, 1.9325088848988353e-01, 3.7566384113023343e-01, 5.3282968116189522e-01, 6.0350989864249149e-01, 5.7965525912355476e-01, 4.9211072915005022e-01}
	pdf_μ1_σ05 := []float64{0.0000000000000000e+00, 3.6133196398262123e-05, 5.1635088434919341e-03, 3.8605538836946451e-02, 1.0798193302637613e-01, 1.9091121772088188e-01, 2.6231743198874347e-01, 3.0934947656586170e-01, 3.3046456598348395e-01, 3.3014730836421469e-01, 3.1471224435057743e-01, 2.9006175609332108e-01, 2.6083887270192596e-01}
	pdf_μ1_σ1 := []float64{0.000000000000000000, 0.092564964593886981, 0.190297804810105553, 0.232162198388356861, 0.241970724519143365, 0.236020867689781116, 0.222876045876282708, 0.206899223293204343, 0.190297804810105553, 0.174166691541200014, 0.159018793463367558, 0.145060158635937686, 0.132335751529021134}
	cdf_μ0_σ025 := []float64{0.0000000000000000e+00, 1.4682810563903740e-08, 2.7806178623095224e-03, 1.2492201715460274e-01, 5.0000000000000000e-01, 8.1395738105609783e-01, 9.4758338235719830e-01, 9.8740456611426053e-01, 9.9721938213769046e-01, 9.9941010348623016e-01, 9.9987640941384703e-01, 9.9997399474076409e-01, 9.9999444730041298e-01}
	cdf_μ0_σ05 := []float64{0.0000000000000000000, 0.0027806178623095224, 0.0828285190016985196, 0.2825225239859443516, 0.5000000000000000000, 0.6723050642884574879, 0.7912971266155286454, 0.8684793210248162865, 0.9171714809983014804, 0.9475833823571983006, 0.9665675815910831359, 0.9784738281117503211, 0.9859977944260549521}
	cdf_μ0_σ1 := []float64{0.00000000000000000, 0.08282851900169852, 0.24410859578558272, 0.38679505713409723, 0.50000000000000000, 0.58828810814254506, 0.65743216948515415, 0.71212923315007504, 0.75589140421441725, 0.79129712661552865, 0.82024278610421464, 0.84413554508743083, 0.86403139235857562}
	cdf_μ1_σ025 := []float64{0.0000000000000000e+00, 6.7937397995560467e-22, 6.3249089875012523e-12, 1.2973843764991455e-07, 3.1671241833119924e-05, 9.4362179184011817e-04, 8.7001192897962799e-03, 3.9073790982167039e-02, 1.0983402486810034e-01, 2.2474092756208025e-01, 3.6887399665533183e-01, 5.1850573500576225e-01, 6.5337527043793608e-01}
	cdf_μ1_σ05 := []float64{0.0000000000000000e+00, 9.0936473087462811e-07, 3.5421674466618914e-04, 5.0067301053332691e-03, 2.2750131948179212e-02, 6.0126457619697919e-02, 1.1720610376847471e-01, 1.8922158674265119e-01, 2.6970493073490953e-01, 3.5266345803129762e-01, 4.3352037059466092e-01, 5.0925535791422860e-01, 5.7817410080287324e-01}
	cdf_μ1_σ1 := []float64{0.0000000000000000000, 0.0085095612560889284, 0.0452137277902241314, 0.0989283283290915555, 0.1586552539314570465, 0.2186217341859028884, 0.2760772061741955108, 0.3298294288332768165, 0.3794777011200848871, 0.4250190616904856444, 0.4666437940564928111, 0.5046279903528034794, 0.5392769436822993923}

	var ln LogNormal
	ln.Init(0, 0.25)
	n := len(X)
	x := make([]float64, n)
	for i := 0; i < n; i++ {
		x[i] = ln.Pdf(X[i])
	}
	chk.Vector(tst, "pdf: μ=0 σ=0.25", 1e-16, x, pdf_μ0_σ025)

	ln.Init(0, 0.5)
	for i := 0; i < n; i++ {
		x[i] = ln.Pdf(X[i])
	}
	chk.Vector(tst, "pdf: μ=0 σ=0.50", 1e-16, x, pdf_μ0_σ05)

	ln.Init(0, 1.0)
	for i := 0; i < n; i++ {
		x[i] = ln.Pdf(X[i])
	}
	chk.Vector(tst, "pdf: μ=0 σ=1.00", 1e-15, x, pdf_μ0_σ1)

	ln.Init(1, 0.25)
	for i := 0; i < n; i++ {
		x[i] = ln.Pdf(X[i])
	}
	chk.Vector(tst, "pdf: μ=1 σ=0.25", 1e-15, x, pdf_μ1_σ025)

	ln.Init(1, 0.5)
	for i := 0; i < n; i++ {
		x[i] = ln.Pdf(X[i])
	}
	chk.Vector(tst, "pdf: μ=1 σ=0.50", 1e-15, x, pdf_μ1_σ05)

	ln.Init(1, 1.0)
	for i := 0; i < n; i++ {
		x[i] = ln.Pdf(X[i])
	}
	chk.Vector(tst, "pdf: μ=1 σ=1.00", 1e-16, x, pdf_μ1_σ1)

	ln.Init(0, 0.25)
	for i := 0; i < n; i++ {
		x[i] = ln.Cdf(X[i])
	}
	chk.Vector(tst, "cdf: μ=0 σ=0.25", 1e-16, x, cdf_μ0_σ025)

	ln.Init(0, 0.5)
	for i := 0; i < n; i++ {
		x[i] = ln.Cdf(X[i])
	}
	chk.Vector(tst, "cdf: μ=0 σ=0.50", 1e-15, x, cdf_μ0_σ05)

	ln.Init(0, 1)
	for i := 0; i < n; i++ {
		x[i] = ln.Cdf(X[i])
	}
	chk.Vector(tst, "cdf: μ=0 σ=1.00", 1e-15, x, cdf_μ0_σ1)

	ln.Init(1, 0.25)
	for i := 0; i < n; i++ {
		x[i] = ln.Cdf(X[i])
	}
	chk.Vector(tst, "cdf: μ=1 σ=0.25", 1e-15, x, cdf_μ1_σ025)

	ln.Init(1, 0.5)
	for i := 0; i < n; i++ {
		x[i] = ln.Cdf(X[i])
	}
	chk.Vector(tst, "cdf: μ=1 σ=0.50", 1e-15, x, cdf_μ1_σ05)

	ln.Init(1, 1)
	for i := 0; i < n; i++ {
		x[i] = ln.Cdf(X[i])
	}
	chk.Vector(tst, "cdf: μ=1 σ=1.00", 1e-15, x, cdf_μ1_σ1)
}

func Test_lognorm02(tst *testing.T) {

	//verbose()
	chk.PrintTitle("lognorm02")

	doplot := false

	if doplot {
		plt.SetForEps(1.5, 300)
		for _, σ := range []float64{1, 0.5, 0.25} {
			plot_lognormal(0, σ)
		}
		plt.Subplot(2, 1, 1)
		plt.Gll("x", "f", "")
		plt.Subplot(2, 1, 2)
		plt.Gll("x", "F", "")
		plt.SaveD("/tmp/gosl", "test_lognorm02.eps")
	}
}
